<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>看完这篇，别人的开源项目结构应该能看懂了</title>
      <link href="/2022/02/25/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%EF%BC%8C%E5%88%AB%E4%BA%BA%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E6%87%82%E4%BA%86/"/>
      <url>/2022/02/25/%E7%9C%8B%E5%AE%8C%E8%BF%99%E7%AF%87%EF%BC%8C%E5%88%AB%E4%BA%BA%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E6%87%82%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载于：<a href="https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/5Ar5B9Ah2BdO8i9YjMQ7Qg</a></p></blockquote><h2 id="我为什么要写这篇"><a href="#我为什么要写这篇" class="headerlink" title="我为什么要写这篇"></a>我为什么要写这篇</h2><p>近来，和不少初学Spring或Spring Boot的小伙伴私信交流了关于项目目录结构划分和代码分层的问题。</p><p>很多小伙伴表示网上下载下来的开源项目看不懂，项目结构和代码分层看得很蒙，不知道应该以一个什么样的思路去学习和吸收别人的项目。</p><p>好，今天熬夜肝了这篇文章，和大家一起来交流探讨一下，不足之处也请小伙伴们批评指正。</p><hr><h2 id="先看看阿里是怎么约定的"><a href="#先看看阿里是怎么约定的" class="headerlink" title="先看看阿里是怎么约定的"></a>先看看阿里是怎么约定的</h2><p>我印象中，以前在看《阿里巴巴Java开发手册》时，好像有关于工程结构和应用分层相关的内容，于是我回翻了一下，果然有：</p><p><img src="http://imag.dragonlucky.cn/image-20220225105149209.png" srcset="/img/loading.gif" lazyload alt="image-20220225105149209"></p><p>它这里面讲的内容大概就是：关于一个正常的企业项目里一种<strong>通用的项目结构和代码层级划分</strong>的指导意见。</p><p>按这本书上说的，一般分为如下几层：</p><ul><li>开放接口层</li><li>终端显示层</li><li>Web 层</li><li>Service 层</li><li>Manager 层</li><li>DAO 层</li><li>外部接口或第三方平台</li></ul><p>由于书中的篇幅关系，它这地方讲得比较笼统了，估计初学者看了还是会懵，所以接下来<strong>结合实际项目代码结构</strong>，来唠一唠具体的项目结构和代码分层。</p><hr><h2 id="通常的项目结构"><a href="#通常的项目结构" class="headerlink" title="通常的项目结构"></a>通常的项目结构</h2><blockquote><p><strong>首先说在前面的是</strong>：这东西并没有一套通用的标准，不同公司或者团队的使用习惯和规范也不尽相同。</p></blockquote><p>我们就以当下非常火热的Spring Boot典型项目结构为例，创建出来的项目应该总体分为三大层：</p><p><img src="http://imag.dragonlucky.cn/image-20220225105259462.png" srcset="/img/loading.gif" lazyload alt="image-20220225105259462"></p><ul><li><code>项目根目录/src/main/java</code>：放置项目Java源代码</li><li><code>项目根目录/src/main/resources</code>：放置项目静态资源和配置文件</li><li><code>项目根目录/src/test/java</code>：放置项目测试用例代码</li></ul><p>而位于<code>/src/main/java</code>目录下的Java源代码的组织结构大家比较关心，这地方也只能给出一个通常典型的结构，毕竟不同项目和团队实践不一样，稍许有区别，但整体安排应该差不多。而且如果是<strong>多模块</strong>的项目的话，下面的结构应该只对应其中一个模块，其他模块的代码组织也大致差不多。</p><p><img src="http://imag.dragonlucky.cn/image-20220225105325539.png" srcset="/img/loading.gif" lazyload alt="image-20220225105325539"></p><p>各个目录详细介绍：</p><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">|_annotation：放置项目自定义注解</span><span class="hljs-string">|_aspect：放置切面代码</span><span class="hljs-string">|_config：放置配置类</span><span class="hljs-string">|_constant：放置常量、枚举等定义</span>   <span class="hljs-string">|__consist：存放常量定义</span>   <span class="hljs-string">|__enums：存放枚举定义</span><span class="hljs-string">|_controller：放置控制器代码</span><span class="hljs-string">|_filter：放置一些过滤、拦截相关的代码</span><span class="hljs-string">|_mapper：放置数据访问层代码接口</span><span class="hljs-string">|_model：放置数据模型代码</span>   <span class="hljs-string">|__entity：放置数据库实体对象定义</span>   <span class="hljs-string">|__dto：存放数据传输对象定义</span>   <span class="hljs-string">|__vo：存放显示层对象定义</span><span class="hljs-string">|_service：放置具体的业务逻辑代码（接口和实现分离）</span>   <span class="hljs-string">|__intf：存放业务逻辑接口定义</span>   <span class="hljs-string">|__impl：存放业务逻辑实际实现</span><span class="hljs-string">|_utils：放置工具类和辅助代码</span></code></pre></div><p>然后接下来<code>/src/main/resources</code>目录，里面主要存放静态配置文件和页面静态资源等东西：</p><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">|_mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><span class="hljs-string">|_static：存放网页静态资源，比如下面的js/css/img</span>   <span class="hljs-string">|__js：</span>   <span class="hljs-string">|__css：</span>   <span class="hljs-string">|__img：</span>   <span class="hljs-string">|__font：</span>   <span class="hljs-string">|__等等</span><span class="hljs-string">|_template：存放网页模板，比如thymeleaf/freemarker模板等</span>   <span class="hljs-string">|__header</span>   <span class="hljs-string">|__sidebar</span>   <span class="hljs-string">|__bottom</span>   <span class="hljs-string">|__XXX.html等等</span><span class="hljs-string">|_application.yml</span>       <span class="hljs-string">基本配置文件</span><span class="hljs-string">|_application-dev.yml</span>   <span class="hljs-string">开发环境配置文件</span><span class="hljs-string">|_application-test.yml</span>  <span class="hljs-string">测试环境配置文件</span><span class="hljs-string">|_application-prod.yml</span>  <span class="hljs-string">生产环境配置文件</span></code></pre></div><p>当然，这地方估计有一个<strong>很多人都会纠结的</strong>关于<code>DTO/VO/DO</code>等<strong>数据模型定义</strong>的区分。</p><p>这在《阿里巴巴Java开发手册》中倒是做了一个所谓的严格区分，那本书上是这样去定义的：</p><ul><li><code>DO（Data Object）</code>：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li><code>DTO（Data Transfer Object）</code>：数据传输对象，Service或Manager向外传输的对象。</li><li><code>BO（Business Object）</code>：业务对象。由Service层输出的封装业务逻辑的对象。</li><li><code>AO（Application Object）</code>：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li><code>VO（View Object）</code>：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul><p>老实讲，看到这么多对象的定义，我也是很蒙的。实际项目开发时，我觉得没有必要刻意照搬去定义这么多层对象，这样后续做对象转换工作都能烦skr人。</p><p>出于简单起见，我个人觉得，只要保证业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象严格划分出来，确保互相不渗透，不混用，问题应该就不大。</p><p>比如在我上面举例的这个项目的代码结构中，<code>Service</code>层处理的对象都定义在了<code>dto</code>包里，而<code>DAO</code>层处理的对象都放在了<code>entity</code>包里了。</p><hr><h2 id="项目结构划分总结"><a href="#项目结构划分总结" class="headerlink" title="项目结构划分总结"></a>项目结构划分总结</h2><p>如果从一个用户访问一个网站的情况来看，对应着上面的项目代码结构来分析，可以贯穿整个代码分层：</p><p><img src="http://imag.dragonlucky.cn/image-20220225105416880.png" srcset="/img/loading.gif" lazyload alt="image-20220225105416880"></p><p>对应代码目录的流转逻辑就是：</p><p><img src="http://imag.dragonlucky.cn/image-20220225105548609.png" srcset="/img/loading.gif" lazyload alt="image-20220225105548609"></p><p>我想，应该看得比较清楚了吧。</p><p><strong>所以，以后每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</strong>。</p><hr><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><p>1、<code>Contorller</code>层参数传递建议不要使用<code>HashMap</code>，建议使用数据模型定义</p><p>2、<code>Controller</code>层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到<code>Service</code>层代码中去做</p><p>3、<code>Service</code>层做实际业务逻辑，可以按照功能模块做好定义和区分，相互可以调用</p><p>4、功能模块<code>Service</code>之间引用时，建议不要渗透到<code>DAO</code>层（或者<code>mapper</code>层），基于<code>Service</code>层进行调用和复用比较合理</p><p>5、业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象不要混用。<code>Controller</code>层的数据对象不要直接渗透到<code>DAO</code>层（或者<code>mapper</code>层）；同理数据表实体对象<code>Entity</code>也不要直接传到<code>Controller</code>层进行输出或展示。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于DTO/VO/DO等数据模型定义的区分</title>
      <link href="/2022/02/17/%E5%85%B3%E4%BA%8EDTO-VO-DO%E7%AD%89%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%86/"/>
      <url>/2022/02/17/%E5%85%B3%E4%BA%8EDTO-VO-DO%E7%AD%89%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载于：<a href="http://www.blogjava.net/johnnylzb/archive/2010/05/27/321968.html" target="_blank" rel="noopener">http://www.blogjava.net/johnnylzb/archive/2010/05/27/321968.html</a></p></blockquote><p><a href="http://kb.cnblogs.com/page/522125/" target="_blank" rel="noopener">上一篇</a>文章作为一个引子，说明了领域驱动设计的优势，从本篇文章开始，笔者将会结合自己的实际经验，谈及领域驱动设计的应用。本篇文章主要讨论一下我们经常会用到的一些对象：VO、DTO、DO和PO。</p><p>　　由于不同的项目和开发人员有不同的命名习惯，这里我首先对上述的概念进行一个简单描述，名字只是个标识，我们重点关注其概念：</p><p>　　<strong>概念</strong>：</p><p>　　<strong>VO</strong>（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。</p><p>　　<strong>DTO</strong>（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。</p><p>　　<strong>DO</strong>（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。</p><p>　　<strong>PO</strong>（Persistent Object）：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。</p><p>　　模型：</p><p>　　下面以一个时序图建立简单模型来描述上述对象在三层架构应用中的位置：</p><p><img src="http://imag.dragonlucky.cn/QQ%E6%88%AA%E5%9B%BE20220217160406.png" srcset="/img/loading.gif" lazyload alt></p><ul><li>用户发出请求（可能是填写表单），表单的数据在展示层被匹配为VO。</li><li>展示层把VO转换为服务层对应方法所要求的DTO，传送给服务层。</li><li>服务层首先根据DTO的数据构造（或重建）一个DO，调用DO的业务方法完成具体业务。</li><li>服务层把DO转换为持久层对应的PO（可以使用ORM工具，也可以不用），调用持久层的持久化方法，把PO传递给它，完成持久化操作。</li><li>对于一个逆向操作，如读取数据，也是用类似的方式转换和传递，略。</li></ul><p>　　<strong>VO与DTO的区别</strong></p><p>　　大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举。但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。</p><p>　　用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。</p><p>　　理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</p><p>　　<strong>VO与DTO的应用</strong></p><p>　　上面只是用了一个简单的例子来说明VO与DTO在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。</p><p>　　在以下才场景中，我们可以考虑把VO与DTO二合为一（注意：是实现层面）：</p><ul><li>当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如JavaScript）或其他机制（JSTL、EL、CSS）。</li><li>即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐。</li></ul><p>　　以下场景需要优先考虑VO、DTO并存：</p><ul><li>上述场景的反面场景</li><li>因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。</li><li>如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。</li></ul><p>　　<strong>DTO与DO的区别</strong></p><p>　　首先是概念上的区别，DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的<a href="http://kb.cnblogs.com/page/522021/" target="_blank" rel="noopener">一篇博文</a>），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如<a href="http://kb.cnblogs.com/page/522125/" target="_blank" rel="noopener">第一篇</a>系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。</p><p>　　<strong>DTO与DO的应用</strong></p><p>　　从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。</p><p>　　对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：</p><ul><li>两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。</li><li>DO具有一些不应该让展示层知道的数据</li><li>DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。</li><li>对于某些ORM框架（如Hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。</li><li>从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。</li></ul><p>　　对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”。笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。</p><p>　　<strong>DO与PO的区别</strong></p><p>　　DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：</p><ul><li>DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。</li><li>同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。</li><li>某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应多个PO的情况。</li><li>PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。</li></ul><p>　　<strong>DO与PO的应用</strong></p><p>　　由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：</p><ul><li>对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。</li><li>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get/set方法私有化，甚至不提供get/set方法。但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。</li><li>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibnate的相关资料。</li></ul><p>　　到目前为止，相信大家都已经比较清晰的了解VO、DTO、DO、PO的概念、区别和实际应用了。通过上面的详细分析，我们还可以总结出一个原则：分析设计层面和实现层面完全是两个独立的层面，即使实现层面通过某种技术手段可以把两个完全独立的概念合二为一，在分析设计层面，我们仍然（至少在头脑中）需要把概念上独立的东西清晰的区分开来，这个原则对于做好分析设计非常重要（工具越先进，往往会让我们越麻木）。<a href="http://kb.cnblogs.com/page/522125/" target="_blank" rel="noopener">第一篇</a>系列博文抛砖引玉，大唱领域驱动设计的优势，但其实领域驱动设计在现实环境中还是有种种的限制，需要选择性的使用，正如我在《<a href="http://www.blogjava.net/johnnylzb/archive/2010/05/26/321873.html" target="_blank" rel="noopener">田七的智慧</a>》博文中提到，我们不能永远的理想化的去选择所谓“最好的设计”，在必要的情况下，我们还是要敢于放弃，因为最合适的设计才是最好的设计。本来，系列中的第二篇博文应该是讨论领取驱动设计的限制和如何选择性的使用，但请原谅我的疏忽，<a href="http://kb.cnblogs.com/page/521969/" target="_blank" rel="noopener">下一篇</a>系列博文会把这个主题补上，敬请关注。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影视资源解析接口</title>
      <link href="/2021/09/04/%E5%BD%B1%E8%A7%86%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/04/%E5%BD%B1%E8%A7%86%E8%B5%84%E6%BA%90%E8%A7%A3%E6%9E%90%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d9a6433d9966f45c58b00a3672ef95fe7e7e01b0b1389ec60060f4979d7ecfb">8c10b25a62c107aaae56fa284d003ffb90dbf0e3d31bd2ed957ae6f1eba2ec81645089feffe66cc0ebf0d3078cf917e94871dca66fe1fa725400dfbb0c78c5f7d5d555f309507a0e63a9b3430ca0bdd552d006f0b35be694f6fc11af093703866d6300ca63cc0cfd3dbd2c187d183c9645ef28ea417cdcdf3844ad67406ad338d88df1aff0551ad4272280ae2fb40011461638742b1ecab429b514ca9b5e25dbfefe0d250018abe165da6cedd0d157f7803704b03c7b231d70ec07d35ecd32132e1a69987ee5c07361b8b403b4e62711363ea36d9bb217a8e73f8fd7b3f158192f35f1b6c6888d41cd0444e540a63297ea2325fa70ef603ccca1d00a6ac1b56462974103b69869d9c0377c5455505ba90d5fa8be2880082e8b7c582f4f0dab1507eee728ab77a1cea0a2f95a16ec86fddc3f57adc8f972ce82f4e501e4372185ec9dc7b740f2260a9a2aa1d8be6a9062fbacac7b168ece69ad92cc975fd517427d11423fffe08b642588bab971eb88c512bfb6fb1d6fa6f151622c1022e95d26a200f20f71fbd1734efa3736c41bd6fc870648dccc415ef685c1fe50e6eda9666b4e40d4c2ac0a689ffbbe0255b0f10220040bb19310efba151ad1fc7bff7c0a96dc2f5669a083300c7fb8211d0a85599f91ec40a32dc8dbac0553040009cefb1c7fa4c4415722660e773509dbaa06afba19052b5e4b3d45ef35d7889414c66a3ec6a86ccfc1984375b85f62753c1e819689f11a7c63456e0529da66789e9d4ad03f261eeece652a25e4713369731d2e1c206a8fb7f6ba4d1525fd1786029838109c7815b14970cb08367ddd5d34b5525563077458c6b98bc32e865cb1bb256933c1dfc31b0e908b57f01114666faa1cfc1c14f9ec752cd9a1a7ce95b55d27b3c75f2fcc0a3e46b52109dfd62535229783bd1cad0ca5fe4ccbd657a9ef9155acf7d923f2aabb9a3ba4db7bb5e7bad1467bc99979d925113ad456f3b5767ff8b8c0c6015fcdc437aedc4f6c04bcf0d318e1921dbd3c3b2b6904149e6f1fd7a15542b604f732300615f1eb707f6d2ca72c4980b89ca8cb6a27ed7e52ad0422744f75965b38189941c813dfb1707d00aed1c7393c7ea3a0cb5c0561889220918f03633fab1af4f5752e76743093b44cf10ca9788b0443625095d658fae5b42edbdb840a200131823416eecbb2b7f1bd9adada9296926f7b9ecf5a4ed31702ba5b842520be9a8c78a6d91fcb59c18d85e31270bbea4882e1157a6879bed8ca3ff80ba1c9cc575d7423b3022c478f153729ebf630edbcc914f4bb7feaab49bded8c1e277f0d334ebaa03e8954648255bb218f54054517e9c2c0cf18bc41a8d1aa457fb83bbda357f8f4d9c9d27f02b0d1b2876c985cfbe6af211b662338381d2547ae61844604ffd678495848c680217eba002d6c50f12d01e2138d8d323f5e2503cb304cc3a995bfbc3f7cfee0de01ccc0f2c297a221ed03a031ab617872b9406472a91a6151a1cfede01efbe11ac5bd58870217c23a08429421cf272d8a2275239c4c1397ecca2b202700b4d7c66db8bd71b765d27d86b08756c8cd748b5482639411003206be2e656f31763a0a3c7c93c012bde69144f61d7ecb1ba8908d11eafc6937c2905d310aed8ace5ac061e940669459ae8c1a5b4155840fa317d6800f212548f4550ca5c7905c5b8bbd27015b4455d24f5137e1a0aa3426968de304c8b0deec7ffb8885ad3c10e183f60a9b7046a384a08c414df415c681ce5401eea466a4a0a7d0b94d46b1140861ef9702b79a57b43e0e9d2b38c9355e0893c4637070988261768d32ca51040c05fabf0515202a8d81d2a9cdbdeed6bb34474cf25e473451d45802c068f3aa198b5cd1e9129c96e5df89fc90b9c145f5e1445eb9120f7a96ad836f195c798125ef24c091bbb8222bccfaba15dc03a58c98a780cf0e557439abb91552eebd6b720fc31de84be8207c97c08db8284e2a1dc1c03dd5fca5dd53511ffe95b83873488193ebffa8542560a049bbbb6519001bee28d29c73e4121d2dd98306b2590c4673b9a37702a47aafcdb39a4ca1ee239e6c098c44b2897c7714811a7a7719b8845a2fb4663948d99e19724f7d1bb7339930621c4af85bfe3d13ef0e4b139e31cf670197ca45748530d024d602193fad78fd0c2c5ba6a47c9a9ad0debb229f2e453857f518ba983cf8fde17e005d903aaa7d59065d2e0325d9989395f6b976b85cc26a029ff0c32a91ce75441d2ef22759baaeb2bceb1fa11342ef71805123100683e80b332d07d140e12b024c243d41d5e7261dd13fb542e68ae2e43dda334d8c7383b4f7e1a2887bfb0ce3f34555cfa2f8652bb40b99e51dddf9b87c338a0c265c6ea462385121b77403f639a0f726881f82aa669ad2805fdca042d2d797abc94bbafbd832ea766ccd816254de1b62cd3cb94f300b74a2a63bdbd0e17ccc8fabf3ba94bf3a4e522d1fac277f7e5dceb7e13b0709571a7adec21d84d09318fd6d7e893e44f4d0eda04528f63a3a32eabc5574868ae7379c1f215d3f58e0114d9dde5fef38ecb9d78a8446856f558156bd652a831a9e242ce8d0d350d69ea5bf8bd693ce45c026f460a0dc85f108baaccf7461f7eff48ab6150cf8510e34906521f0043fe7ff18580276a19462ef8876277af8594133e20d61aa667be59bfdc60b95a1c2a353a4cc7eb3b5611c04b94ad7138d9ff152d9357f82e61b0ca1f6b5b2eba083f6102e74986f5b03be809d6a22f12fae41334ad39ceaffae820080f392856b86981272caaf9d85e263b50cc72c11efcee83f41cb856a9d826de1fbf52de12ccae27e9afb9b2048aea8cc0b59a36cf74ec8e5975239700bc6fb55afbc30d084840f5b35db23077d4c77a149663b8aa074e36cb0fc4744a62833f3c22de11ea1ddcce50831082aebd23ddfaee7542fd51f78c85286d3f5e1db1662d6d07759a5dc7178d7ebfaf911b14ff5c8d714983101f628cb31d64dfd2798397ebe2c4e804fa1f1b43825561b124fd0fc52f2ca21de99ec88db4d741b7bfc504646e34ac373aba6ec4672c7c6cf28ff52ef6308e8307e7005d0f31f0fe520acd74dbcab3e21bc43d06dd27a7c8796c68e7c519d73752b56eff521117b96b68b3d2a3d438a967af2133cf9c46dd251c794dcd0a6a95f8be3230d4e1a7f7bb0deb7916538816cb21faa3f8b468a9592c39bcd3a0f2ffbbff798fded6443135b7e3c3afc0665c57475cef737304fd9807d658225cee5c21a62c1616362ac2bdeeaabcf8bcc41033c2134fe930c2a4bd665e58bb0f77e86e208908f4bb34bdc77548959540f613739fcdd862648eb1cc81ec217f79c60ca1e4fac15af80a648842068bf4f7af6622ee68e52bd86f929a438a0b15f6355a9c3e5ff4401a2dff234a5cb5e489e196818e1e6d5204bdb921863ad8a7e846569d57b9fab5d8cc50a1fa1f5095d4fd9b39be017f7e63dcc956e18ddd461d0b6531da33c5dc72ff1193e92d56568e61a8ed0a16808ba1091ee5cec954eac5719ea48ee997f4c4138521b7bb770d463516714c3a97fed56783dc63e82d2cc3b0c9fcf8962031eab60528e418e734728427f63283abfa6f859e6c73031abb1098ba17c76e80ceacc27a391fd134bf1e59a74d78d35c2b75f854637e3f75157befcaab8590e02f201c5495ef71124676a65e2d6a222d933a448104095d5c65a3e2e43ed05fa1c8a9f2d0c593cf26034d7bd8db933db420070df8132ac630f048e0dd583a18e9fc25918ee6ad34ac270735f37657c5d70396a0a00ac04627e1c9a2a0f33b124c3bbcfaf55b371f577e6b7bb593b1ca38a54447131b3934d07ef0d972f7d951df2a729f399338ffd715aa49c0a2dccdaf10855cf72c56c3a278b52f916179f1c69d693e3b924f1309214dc5d44252085a48364d32abefefe552bbc663fde57323b49070239369b33bc8686906e4f618f5f47c16c2625377fc23f1ea95e1aaa755823b85188775f81ab7dc3bb12397b36ee66ea2c70f052956743ed1b451d01b4c399029e46ed5dca692fff9740c9a522e49ae9860096e874ea99d37db8f7b0be5f57ad64021c4dbb5087904592526cc45806ec2f63cabed658a59a7cf46af7efc4d278920da8a487df091560f4db891d873c4001c928fabfebe1920234fe54a43c09d89d898f6a086f8fa55b3a589de81e74ffe6da5ad3283a72d54addba47e480a66d9c157514f4a7ec13e04550184ae9c824a012c951d4891340ef777d1572a08c024ec7175ba0e8f351428af1c45e4bf2bd39ba3c2dd407ca3f97aec51017378e0bbbaa4bd5d8dfa6e2fd761d4a55afb28ea1c2b7b7c505bde6ae7816784e48c02117360850b249cb951190914c68665ab6130512cc0259d4da9d44aca795056fbd8fd163c428d17171589af35672cbf8dea7562cb43b5a893a1fb54ea7823c8e91bd5ca8091e3823bd259cbbceedda830c201bd7375ab6dce5d1d54620a265e14ef0531f45c83aa5f86fad66ffab7d77caa662fa1ca62dc70ec9b08bd9250082f65cda1465bbde3f4dbc8c4332e8ba9826949e8a28932c44ab9ba159ca2d26a9a821a7440e5917d0fd806284af790e8e788cd843adbe4a3b3c1172790ebf77e5a62879c80aa06464237a0f11c3d0592ebaafefd14a4ef00b9ce0ae1f46e31546d080bc85a0770660605f6ae1bfddce7dfd89da8f7d5f0a7a8edc17e5a90d3dc966a04162565121e99d5cf05422bd2c3b8d10fac13956f4d0c7bb74cb056b715f662b435a7541bd63466c9ea7d953b4fc25a0352b62d77cdeddd4006d2bf641f4679170547ce0f5c90126d8b97081266b520b4f730295aea3aa8ba3b07a993092cb2d201be5800f4966abb577383e282a6dd15db560e2dc947b4c55c6b6585286ad3a094b6d5bce389166bed7cf132726ba2dd197c9108f21cd7e13416b57eecf9c0719375cabd7dcfb7f7772290e0eb9262bf42651a7ef78d14edfbdd4c4d2d0b44bbd207e0f75ea741bc15b0f2a65220e9df0161c78a9fdf4f77dd8992d532557520197c16a164f2116aa0d3aa01df6f29bc0844d7ec3940a00b93dc4900f3f14fe769717625876a112a5175ab5f000a44c6e5acf73c101ca903a37ff4ffad713740ef92bb5b302f4b520dd5ae3ed68711c1b52c19f79c24ad4b64f1b4477b62454612e83090d42061f7ed5f6a59bc1683bbdebb6d707a85ae58b1ed5e48f76f475ad7d6c7eaec757da55ed4ba646b6a5be531322b569a769bb84c452258db07e34a20dceeba170c84f47fc982b4549e13a45fcd22c20e80d86d39ef73240b20cee1601fe975d444695a6df05ecf86125f2be4baf1434014fc99db8b19419d751c6321a3d6521cd4e42574e68e4cb83b05e04c5d33216c74dae41b5ead35fda5f7d68afef27f81ff86f59cc483c3081fc797f2e07490fca2788b54fbf230a0de113ea47d6d0b49a6b3858c7e56051bbbca2ca606532b6b1bf483b483706c7a1d03cf8666610835a643029e9efa083e3f397ce010bf1b8d0ae2a7d960839cbaedeab68bbddae44defd8770a69eb3948887d08ce99f797faefd291acca360fe0bb26cb120cce16d398db7b17d84f89888b94d7a8bf7ff1c69e3cadb54b49b9419996b3c979475011ec56587a463905f602799ba2c71f06afad89827404f3f3800ee20eea211d66fbe50be40073955fb8c49ba711290393b6e675a32d6a25a19fbc2efe1d63aaaea8f73e99eff9bb643ec4b5f5dcfae1ba0199bc0a0721e1d5681f17b1b4a954c72ab225b0a1a65169b796fc5b531b720f7c23d2c573a55b6d3d49a2cf1e21d02e85d218d32dea5f5797d81b166e50738b894f2a17c0160c5c18c365d3e3e228fda35cf112f7078d8336cbbbf01f87eefa7c2d58b07126a6742c74660146d40da7faa2282b333d9568df3630e37f3a46e2a4849a6d8863ee084d64c2f0c34defdef8e4fec63357e6ce71c25d6a8929f35308394c2c3edacce70dd0779d6b50ad138fec61424ab0abc73e6433ab4840fe4b8cbeab6973097cb8e186ed397200992376a7602b6916ebee679c59d3cd82b1eb254b6865ada2cd66271696dac6efa5b0e9c9d00f0deed927b0d6c13ea30c5bec4c90b274884bee4344d7fe1f209e81b02dc85fc32ac70e95cb72225ee65c47e06e3162b9eb30b2b9d9f11b7cb3f7cb3f1439452738ed0d30f39a8e64454abcf2b6d8c768bce4dfe7a1ecca935294d62bcd222d62e6f295977f1a6f9cdd84bc4f37ca53d54b122790c22e290d0175af99346fefdfe6400be4e6fb0df666d868d1905cbb0893ad4d6eec28f59e0757870fb31768e517c9bbef409ee45e6cf889d67eea6b05b05dfbca2a3afaa47faed290f4485977d174b408cc1c8cf7f8958fe53516e9ccfdc15ec762ae9157e97d9c12c7ba3d63bf9321bd72d84214dcb0e880e405cbee5867298d16fa15b07e596943b326b80598ccb4b5c7a68f4fcd8fdca7b6846437f3e74d12391683735c1f422d54595f0cf2e6092a97d27f8720db18edd86f6683c37cc5ffd8206dcf4b4e8bc22720068d2e6b0b22b7e6e05d8981af1b296c242ae5361c2d1e7cdab0da338e900384dd145595df75ed69b7133fc273ea807f7f7e7b39074f5792585949d51926da2a3c0b2e08e3ff6c761157513a55626c51e9dcd4273370588412a293ec846ce6c476fb25065fd046e247c17c33a70b2e069c24ab0e2cabce43641eafc896383c12d4f7d0d67e3276b82ba2350e86afc7e1af5451fde2eb2a52f4b83a73d2867b2a747c85a612838c1409d11494794f1b7bdd17e2c6e39c9797eb6d5ea2a51981e9bae3152a1de65f453b1216c4e1098a7ff80bdf8be45d8c928a64cf8d0d3901960c4bab2757bada808c982545b76dc2777c892022e5866d8fe409a6d2d999ca4b8b9344fffdfe63b85d9930df7c34156e77f32589142bf533f673ea6f6501e33bc4851413352d96ca86e3993212faf6c3a541106da33313e8676d2d2d1548d6976a80cbb0352694d0f20f105db2794604137159dab46cb9a3bbd524c2130a29794d9dead713d5c5bc14bec9e9207bb4d3f72390f8c42dc2bbb4f017014ae68b64f4c629f167f74cb64f2d860b791a6b985758312c500d1b6c58ef5b8dba61105b8f5a23124f8ce0b0bf8c100529aa67659be7ee5940eee99b50a1468297d982f7faed728c4762073cc30638c861796e58fdab4011d66d92f8ad26c73829bd631c9cce26a2e5a4c0f277abf1287b94b4e0f3bff5ab51e11f583a781844bb08a254305733ea6ea7e09a5b79e751fcc0b3f64258694431c4afed2abb394897dce2d294fa675ea999309add17746029bdd4fcb61911b16ebbeaab287de741f4d733ff519483dd99e3a5a9a07d8f1b21f3db48c1dc38577c23ffd55ccb9385df06ae36f735047d69405b26d8089a8e0396a96fd88d99e0838aa779218acd74edba943a92678c43558667dbc4593427dff81201652ad5f4b3b7f689f3c087587e05b5f4ea92ee6e8949fb19143c347c2a02996cd4af2c86c8aba3c4e23d0952bd74347e2989018619721b9c12093e08611963f1e13cbb00ad872563e1e33c266f19ab5d9ba825384ecdef1d11a42577de814621ba24ac0d1d4269d497177c55d2d0ed52072c14334e20d42426adca999fde681821948bdcfb81912927aefb216c8697c9436cfe24b18dd9299f1f7fc71854279c9e7c8dce017987d5a00bd6bddd75346e315332433ccca1da7b1227d5f883e4c692136fcedc5b018982cc5d4bd5bb90e000c42f7cb3b069ce73bf1d9f8830d93bd73480eb95ea1bd8d624fb85c15725db99bee7846dd9d74d2cfab1e9a76661bde06c2dbb3000bb6a9e9db346370594fb8877493e58c4829d3a25ac5013b598d51ce4b0969a837518e48fefc05f1eb2acf0f98b00d2a06632a8e771a46cb8508d6c200a13971d6192b882be88e38921a46e068141a95deb16fb984a8955316103206d4a73381f342523ad82994cec8fce517ff019703b76aac13dea1508bb40c740090df2491d0de820f28e2c6beea06b4025f69b360cd02222f408bbea3edebaa81286587414cc88adf2efa60da553440376aad7a29c2372f90e854461b45eb8511ec248583d38f98082cd86af01d520cd72be44f3dc156eca6815ef91f145320fa8e2cb8ca8ff9ec87321afc6adf5149a5a68f5588ed45dcdff809ba435bc587f63c56452a63ce6cf5d42a828a7e2bae41f033007feb64b6ce2e74ffc10902959e02210a0e516c5fcfbc4d177fae958c5edc85043b9359b52ba8215029d4d9eef79679b91264053247b00e0013cf6ed1444b48473ffa5aff0bcf0ea43805e293cbd1522333c103efc3243983172b8d05cb6be3945123e24d3f98e307a14fd31623533509281358497983e949ba5a0eb470d34f9318b59b57dd2667d93368b50f433fd9b1edd752c6a76ee858ed6fc7d37501e4dee4acce8b12c434e99e81c6c7bab463aca79bff8b8f4cb78c01f0de963e2c24f61474b9bb780960d24916a5366c22866b8ed6ef57df8dcffc0e3210561e0c90cb7be0ca9f9766cafff2d031cc6dba9198d0b5ef4222a7266986d0287384c3b53ba02436ca2ddbd5321a2080d6bd27f8c6294950e10beb664f2527dc77f3d280781da7ead208380796138b120fdf01381bba9b62c042211adefb1334b0b848a9e14d545e35a71a80a76a722b508cef70339614e10056ba4b2b67045cdfdd1ccc18bf7c9ba4232ab5dda1552eb34fd2800b513397d819917497a581507a861c989afd853a43d196284524798c329e9ea8a9c1d08561a78064f3e80f10d1e340106c001d631e2993711601a5c8de730d6299a0efa850c060acedfbc383fc35a626ed72f49c529fe1b36692b7e3d40e28e45042480378df1d572677ecb97535a1611ebcf8d71cc98c372e7078ffb0443ee73929e458851ccceb2325529c29d96054b103a9518747d19ae81c403b1e1500b23d5126d9c1d3aa8d7299349f64be2ca5c7a153d31bafcbf92b0706e1d8cb42d193a4088e81164924a6e23721e1285c5ea2b9c54939f0506164ee7ea0cdd5c3c96a82c7dab650dc24f8499449b9500f9b4a1b772f8fe849fbbbedb59d4c4f6bab9ed08f0bff69c4e28ba8070e43df0530dd2988c49117fcfa3a099e9912fc4e171df5255fbed25dfd5fb27c1218d1e6e14741d511aa346ea3e4325190ed1dacda374e525495b2871a86e2c88f189e6aa612bfbf9a4171e738310001ed317a4f9f1b6d07d6b4bca2680150f504db3d0a0f851b419a2af1d3832ad3a000800ffa8f78eba26751a792b82334c5024caed6ca640229d45829898053271e136e5933169a218942c034581523dadf7a394643c5c4b00d037d6e3c66b9c04827bdc2679988614f7a33080c50d5d3039262d07824e413ef00ee3115762565c483245ddf9fc43398cf1bec97124766dfaf15144db2491e23d45d2a5f744275f8725c56e35e7f3579008c0d76b5ffb116bc656bbb6b6d2db84e483e916ed48ed356e7372d95d01f7a76760ec5655edb37badf1b5ad11e128c8c68dec537986c0be96e4c2e95c85d50938bae67179ae71a7e802e5234494ce4e5a96f245d57b41ac84b4032b7d912a0a8907c1e1112a1217447058a411f022d359b69a0846b1c85f517735c61eeb6366af93ec0987314a0f8cab5019cff508aa468dc1655fcbfc4b0af3b8c3f268eccf74dc6e56cca2df25c4d7c044cdb3dc05b4fa3eb7bad63b9f151f5986ba4df8f755ad8083415e053ce1047608ced72068162dbb00dec1565971a443795b37191b658904fe027fc00ca2bdfbe39c280f26e5b516084bc92791e7822d54030b608792298672ed8edc933a49b6a81579cdeda646a8489a683fb24dc9fe3376197789fbe54c1039a329fa964d19499f20f957a9de4f14526db7d9de685fe32a84f2100841abb0e8185fbf14f022cb275dcd746a6811b9953627463fb1e43785364d81adafa8d017d8a1ab83e407b073b6b78e50f8094827ca4ea7e8233791545d74a9a63723f72a85104c272b91f99afbe99dd5e8919bef50a12857e0bd699e8ce797ef0e94c54b5f550015e78ea8bdd7e582a09cef0c032d35d61d50ce1f37c85c6f9539aa128ae220fdf23686feec560f1199f67276d5f42a29c6d7eea9c605fa4e15e58d5900542def1b29beac890967de21730ac9286e029697cae38159c628f5835db836a6c493c54cd62038ee5f549577150b06234b6ae33639d939539f97ac51883f77c0f27ef227dfd007e35612026ce348362f1127122103af817f3ab0529728227473818e3f3df6cc2c848e296d24944ff47c5b69d8b10288d7f7852448ab88c08a0140d23b748b6514bd35d3ef470ca9960ed43c6a7c6af8407b1ada88b6ba612d8cb31916ef9de570d62a1076615cb48c989e351240a63016f63ded5d4fba158051cf8957a84c92d782fa69c25e65ee07f2444968d22a152fae7581944ab4a4f81c962af0413775de0a11052aacf20855f8a77bbbda99389b665cb8e13e52d497328ef3abdd180383751e5d6fe2584703cc9d335f704d1e2b7fdeba450e5291c63f64fd5a5bb408ad73fd260e40d978855c678b8bf30895eb8751e57e862c35c819f90d15a514dd666a549585931aac4eca497bb98ff02e556c593094d502b56a6b1681be5f822440d54381e7492e33108102488bff046ccfa102d27b32455f47733b0a8078e6951ca7c3d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium处理弹窗问题</title>
      <link href="/2021/08/02/selenium%E5%A4%84%E7%90%86%E5%BC%B9%E7%AA%97%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/02/selenium%E5%A4%84%E7%90%86%E5%BC%B9%E7%AA%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Selenium-处理弹窗以及iframe-处理"><a href="#Selenium-处理弹窗以及iframe-处理" class="headerlink" title="Selenium 处理弹窗以及iframe 处理"></a>Selenium 处理弹窗以及iframe 处理</h1><h3 id="1、弹窗"><a href="#1、弹窗" class="headerlink" title="1、弹窗"></a>1、弹窗</h3><p>在使用selenium的过程中，可能会遇见弹窗，常见的弹窗类型有：alert 、confirm 或prompt 弹窗。selenium 为我们提供了相应的方法：</p><ul><li><strong>getText()</strong>：返回alert/confirm/prompt 中的文字信息。</li><li><strong>accept()</strong>： 接受现有警告框。 点击【确认】</li><li><strong>dismiss()</strong>：解散现有警告框。点击【取消】</li><li><strong>sendKeys(keysToSend)</strong>：发送文本至警告框。</li><li><strong>keysToSend</strong>：将文本发送至警告框。</li></ul><p>通过driver.swtichTo().alert();切换到alert </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       System.setProperty(<span class="hljs-string">"webdriver.chrome.driver"</span>, <span class="hljs-string">"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe"</span>);       ChromeOptions options = <span class="hljs-keyword">new</span> ChromeOptions();       <span class="hljs-comment">// 接管本地浏览器</span>       options.setExperimentalOption(<span class="hljs-string">"debuggerAddress"</span>, <span class="hljs-string">"127.0.0.1:9333"</span>);       WebDriver driver = <span class="hljs-keyword">new</span> ChromeDriver(options);       WebDriverWait w = <span class="hljs-keyword">new</span> WebDriverWait(driver, <span class="hljs-number">10</span>);       <span class="hljs-keyword">try</span> &#123;           Thread.sleep(<span class="hljs-number">1000</span>);       &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;           e.printStackTrace();       &#125;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//alert</span>            driver.switchTo().alert();            System.out.println(driver.switchTo().alert().getText());            driver.accept();           <span class="hljs-comment">//confirm</span>            driver.switchTo().alert().dismiss();             driver.switchTo().alert().accept();           <span class="hljs-comment">//promot</span>           driver.switchTo().alert().sendKeys(<span class="hljs-string">"hello selenium"</span>);           driver.switchTo().alert().accept();       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           System.out.println(e.getMessage());       &#125;   &#125;</code></pre></div><h3 id="2、iframe"><a href="#2、iframe" class="headerlink" title="2、iframe"></a>2、iframe</h3><p>通过driver.switchTo().frame()切换到iframe，具体通过 id、clssname等，实在不行就使用xpath(),巨好用，</p><div class="hljs code-wrapper"><pre><code class="hljs java">driver.switchTo().frame(<span class="hljs-keyword">int</span> index);<span class="hljs-comment">//如果有多个iframe，可获取对应顺序</span>driver.switchTo().frame(String nameOrId);driver.switchTo().frame(webElment e);</code></pre></div><p>切到frame中之后，我们便不能继续操作主文档的元素，这时如果想操作主文档内容，则需切回主文档。</p><div class="hljs code-wrapper"><pre><code class="hljs java">driver.switchTo().defaultContent();</code></pre></div><p>根据我以往的经验来看，在出现或者可能会出现iframe或者alert的地方，要设置等待。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客更新主题</title>
      <link href="/2021/07/21/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98/"/>
      <url>/2021/07/21/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="博客主题更新"><a href="#博客主题更新" class="headerlink" title="博客主题更新"></a>博客主题更新</h1><p>昨天把博客的主题给更新了一下，之前一直使用的是Next主题。Next主题相对来说比较简洁一些，这次使用的主题是Fluid【一款 Material Design 风格的 Hexo 博客主题】，这个主题的优点是具有丰富的配置以及配套的相关文档说明，并且有团队持续更新以及处理反馈。</p><p>参照着文档配置了一下，使用起来非常不出，配置过程也非常简单，很nice，这里放一下<a href="https://hexo.fluid-dev.com/docs/" target="_blank" rel="noopener">配置文档</a>。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Selenium (爬虫) 控制已打开的浏览器</title>
      <link href="/2021/03/05/Java%20selenium%20(%E7%88%AC%E8%99%AB)%20%E6%8E%A7%E5%88%B6%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2021/03/05/Java%20selenium%20(%E7%88%AC%E8%99%AB)%20%E6%8E%A7%E5%88%B6%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>最近在做 selenium 爬虫相关的工作，起初使用selenium 时，每次运行时都会打开一个新的Chorme 浏览器，这就导致我们在之后的操作会丢失数据，还得继续从头再执行。对于这一问题，我们可以利用Chrome DevTools协议（此处针对的是Chorme浏览器），它允许客户检查和调试Chrome浏览器。</p><h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><p>1.找到我们Chorme 安装路径</p><a id="more"></a><p><img src="/2021/03/05/Java%20selenium%20(%E7%88%AC%E8%99%AB)%20%E6%8E%A7%E5%88%B6%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/image-20210305141211981.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2021/03/05/Java%20selenium%20(%E7%88%AC%E8%99%AB)%20%E6%8E%A7%E5%88%B6%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/image-20210305141411615.png" srcset="/img/loading.gif" lazyload alt></p><p>2.在cmd 中输入   chrome.exe –remote-debugging-port=9222   （potr 可以自由指定） ，就会自动弹出一个浏览器</p><p><img src="/2021/03/05/Java%20selenium%20(%E7%88%AC%E8%99%AB)%20%E6%8E%A7%E5%88%B6%E5%B7%B2%E6%89%93%E5%BC%80%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/image-20210305141558737.png" srcset="/img/loading.gif" lazyload alt></p><p>3.相关程序</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test01</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        System.setProperty(<span class="hljs-string">"webdriver.chrome.driver"</span>, <span class="hljs-string">"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe"</span>);        ChromeOptions options = <span class="hljs-keyword">new</span> ChromeOptions();        <span class="hljs-comment">//接管本地浏览器</span>        options.setExperimentalOption(<span class="hljs-string">"debuggerAddress"</span>, <span class="hljs-string">"127.0.0.1:9222"</span>);        WebDriver driver = <span class="hljs-keyword">new</span> ChromeDriver(options);        System.out.println(driver.getPageSource());        <span class="hljs-comment">//driver.findElement(By.linkText("确认付款")).click();</span>    &#125;&#125;</code></pre></div><p>那么再去执行这个程序之后，就会自动接管我们上步操作打开的浏览器了。在此处我碰到了一问题：无论我怎么配置都是无法实现接管，之后我又在options 中设置了几个参数 ，发现根本不生效，查阅治疗之后发现，我使用的selenium 版本过低导致，所以建议尽量使用3.5以上！！</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 IO流</title>
      <link href="/2020/08/15/IO/"/>
      <url>/2020/08/15/IO/</url>
      
        <content type="html"><![CDATA[<h2 id="一、File类的使用"><a href="#一、File类的使用" class="headerlink" title="一、File类的使用"></a>一、File类的使用</h2><h3 id="1-如何创建File对象"><a href="#1-如何创建File对象" class="headerlink" title="1.如何创建File对象"></a>1.如何创建File对象</h3><ol><li><p>File类的一个对象，代表一个文件或文件目录；</p></li><li><p><strong>public File(String pathname)</strong></p><p>以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储</p><a id="more"></a><ul><li><strong>绝对路径</strong>：是一个固定的路径，从盘符开始</li><li><strong>相对路径</strong>：是相对于某个位置开始</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java">File file=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"hello.text1"</span>);File file1=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\user\\123.text"</span>)</code></pre></div></li><li><p><strong>public File(String parent,String child)</strong></p><p>以parent为父路径，child为子路径创建File对象</p><div class="hljs code-wrapper"><pre><code class="hljs java">File file2=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\USER"</span>,<span class="hljs-string">"234.text"</span>)</code></pre></div></li><li><p><strong>public File(File parent,String child)</strong></p><p>根据一个父File对象和子文件路径创建File对象</p><div class="hljs code-wrapper"><pre><code class="hljs java">File file3=<span class="hljs-keyword">new</span> File(file2,<span class="hljs-string">"345.text"</span>);</code></pre></div><h3 id="2-File类常用功能"><a href="#2-File类常用功能" class="headerlink" title="2.File类常用功能"></a>2.File类常用功能</h3></li></ol><h4 id="2-1-File类的获取功能"><a href="#2-1-File类的获取功能" class="headerlink" title="2.1 File类的获取功能"></a>2.1 File类的获取功能</h4><ul><li><p><strong>public String getAbsolutePath();</strong>  获取绝对路径</p></li><li><p><strong>public String getPath();</strong>  获取路径</p></li><li><p><strong>public String getName();</strong>  获取名称</p></li><li><p><strong>public String getParent();</strong>  获取上层文件目录。若无，返回null</p></li><li><p><strong>public long length();</strong>  获取文件长度（即：字节数）。不能获取目录长度</p></li><li><p><strong>public long lastModified();</strong>  获取左后一次的修改时间，毫秒值</p></li><li><p><strong>public String[ ] list();</strong>  获取指定目录下的所有文件或者文件目录的名称数组</p></li><li><p><strong>public File[ ] listFiles();</strong>  获取指定目录下的所有1文件或者文件目录的File 数组</p></li><li><p><strong>public boolean renameTo(File dest);</strong> 把文件重命名为指定的文件路径</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    File file1=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\code\\123.text"</span>);    File file2=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\work\\234.text1"</span>);    <span class="hljs-keyword">boolean</span> f=file1.renameTo(file2);    System.out.println(f);    <span class="hljs-comment">//要想保证返回true,需要file1在硬盘中存在的，且file2不能再硬盘中存在</span>&#125;</code></pre></div></li></ul><h4 id="2-2-File类的判断功能"><a href="#2-2-File类的判断功能" class="headerlink" title="2.2 File类的判断功能"></a>2.2 File类的判断功能</h4><ul><li><strong>public boolean isDirectory();</strong>  判断是否是文件目录</li><li><strong>public boolean isFile();</strong>  判断是否是文件</li><li><strong>public boolean exists();</strong>  判断是否存在</li><li><strong>public boolean canRead();</strong>  判断是否可度</li><li><strong>public boolean canWrite();</strong>  判断是否可写</li><li><strong>public boolean isHidden();</strong>  判断是否隐藏</li></ul><h4 id="2-3File-类的创建功能"><a href="#2-3File-类的创建功能" class="headerlink" title="2.3File 类的创建功能"></a>2.3File 类的创建功能</h4><ul><li><p><strong>public boolean createNewFile();</strong> 创建文件。若文件存在，则不创建，返回false</p></li><li><p><strong>public boolean mkdir();</strong>  创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层文件目录不存，也不创建</p></li><li><p><strong>public boolean mkdirs();</strong>  创建文件目录。如果上层文件目录不存在，一并创建</p><p>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下</p></li></ul><h4 id="2-4File类的删除功能"><a href="#2-4File类的删除功能" class="headerlink" title="2.4File类的删除功能"></a>2.4File类的删除功能</h4><ul><li><p><strong>public boolean delete();</strong> 删除文件或者文件夹</p><p>删除注意事项：</p><p>java中的删除不走回收站，要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</p></li></ul><h2 id="二、IO流"><a href="#二、IO流" class="headerlink" title="二、IO流"></a>二、IO流</h2><h3 id="1-IO流原理及流的分类"><a href="#1-IO流原理及流的分类" class="headerlink" title="1.IO流原理及流的分类"></a>1.IO流原理及流的分类</h3><ul><li><p>Java  IO 原理</p><p><strong>输入input</strong>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</p><p><strong>输出output</strong>: 将程序（内存）数据输出到磁盘、光盘等存储设备中</p></li><li><p>流的分类：</p><ul><li><p>按操作<strong>数据单位</strong>不同分为： <strong>字节流（8bit）,字符流（16bit）</strong></p></li><li><p>按数据流的<strong>流向</strong>不同分为:  <strong>输入流</strong>，<strong>输出流</strong></p></li><li><p>按流的<strong>角色</strong>的不同分为： <strong>节点流</strong>，<strong>处理流</strong></p><table><thead><tr><th align="center">字节流</th><th align="center">（抽象基类）</th><th align="center">字符流</th></tr></thead><tbody><tr><td align="center">InputStream</td><td align="center">输入流</td><td align="center">Reader</td></tr><tr><td align="center">OutputStream</td><td align="center">输出流</td><td align="center">writer</td></tr></tbody></table></li></ul></li></ul><h3 id="2-流的体系"><a href="#2-流的体系" class="headerlink" title="2.流的体系"></a>2.流的体系</h3><p><img src="/2020/08/15/IO/IO%5CIO_01.png" srcset="/img/loading.gif" lazyload alt></p><h3 id="3-流的使用"><a href="#3-流的使用" class="headerlink" title="3.流的使用"></a>3.流的使用</h3><ul><li>字符流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//FileReader</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//1.实例File类对象，指明要操作的文件</span>        FileReader fileReader = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\Code\\Test\\StudyJava\\helloword.txt"</span>);            <span class="hljs-comment">//2.提供具体的流</span>            fileReader = <span class="hljs-keyword">new</span> FileReader(file);            <span class="hljs-comment">//3.数据的读入</span>            <span class="hljs-comment">//read();返回读入的一个字符，如果达到文件末尾，返回-1</span>            <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">5</span>];            <span class="hljs-keyword">int</span> len;            <span class="hljs-keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="hljs-number">1</span>) &#123;                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;                    System.out.print(cbuf[i]);                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-comment">//4.关闭流操作</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (fileReader != <span class="hljs-keyword">null</span>)                    fileReader.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs Java"><span class="hljs-comment">//FileWriter</span><span class="hljs-comment">//1.提供File类对象</span>       File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\Code\\Test\\StudyJava\\helloword1.txt"</span>);       FileWriter fileWriter = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           <span class="hljs-comment">//2.提供流</span>           fileWriter = <span class="hljs-keyword">new</span> FileWriter(file1);           <span class="hljs-comment">//3.写出操作</span>           fileWriter.write(<span class="hljs-string">"I have a dream!"</span>);       &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;           e.printStackTrace();       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">if</span> (fileWriter != <span class="hljs-keyword">null</span>) &#123;               <span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//4.关闭资源</span>                   fileWriter.close();               &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                   e.printStackTrace();               &#125;           &#125;       &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        FileWriter fileWriter = <span class="hljs-keyword">null</span>;        FileReader fileReader = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\Code\\Test\\StudyJava\\helloword.txt"</span>);            File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\Code\\Test\\StudyJava\\helloword2.txt"</span>);            fileReader = <span class="hljs-keyword">new</span> FileReader(file);            fileWriter = <span class="hljs-keyword">new</span> FileWriter(file1);            <span class="hljs-keyword">char</span>[] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">5</span>];            <span class="hljs-keyword">int</span> len;            <span class="hljs-keyword">while</span> ((len = fileReader.read(cbuf)) != -<span class="hljs-number">1</span>) &#123;                fileWriter.write(cbuf, <span class="hljs-number">0</span>, len);            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (fileReader != <span class="hljs-keyword">null</span>)                    fileReader.close();                <span class="hljs-keyword">if</span> (fileWriter != <span class="hljs-keyword">null</span>)                    fileWriter.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre></div><ul><li>字节流</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"></code></pre></div><ul><li><p>缓冲流</p><p>作用：提高流的读写效率</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">//1.造文件</span> File file1=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\USER\\123.png"</span>);    File file2=<span class="hljs-keyword">new</span> File(<span class="hljs-string">"C:\\USER\\234.png"</span>);    FileInputStream fileInputStream=<span class="hljs-keyword">null</span>;    FileOutputStream fileOutputStream=<span class="hljs-keyword">null</span>;    BufferedInputStream bufferedInputStream=<span class="hljs-keyword">null</span>;    BufferedOutputStream bufferedOutputStream=<span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span>&#123;     <span class="hljs-comment">//2.造流</span>     fileInputStream=<span class="hljs-keyword">new</span> FileInputStream(file1);        fileOutputStream=<span class="hljs-keyword">new</span> FileOutputStream(file2);     <span class="hljs-comment">//3.造缓冲流</span>        bufferedInputStream=<span class="hljs-keyword">new</span> BufferedInputStream(fileInputStream);        bufferedOutputStream=<span class="hljs-keyword">new</span> BufferedOutputStream(fileOutputStream);       <span class="hljs-comment">//4.读写</span>        <span class="hljs-keyword">byte</span>[] b=<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>];        <span class="hljs-keyword">int</span> len;        <span class="hljs-keyword">while</span>((len=bufferedInputStream.read(b)!=-<span class="hljs-number">1</span>)&#123;            bufferedOutputStream.write(b,<span class="hljs-number">0</span>,len);        &#125;    &#125;<span class="hljs-keyword">catch</span>(IOExecption e)&#123;        e.printStackTrace();    &#125;<span class="hljs-keyword">finally</span>&#123;        <span class="hljs-keyword">try</span>&#123;          <span class="hljs-comment">//5.关闭 要求先关闭外层，在关闭内层</span>           <span class="hljs-keyword">if</span>(bufferedInputStream!=<span class="hljs-keyword">null</span>)               bufferedInputStream.close();            <span class="hljs-keyword">if</span>(bufferedOutputStream!=<span class="hljs-keyword">null</span>)            bufferedOutputStream.close();        &#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    &#125;</code></pre></div><ul><li><p>转换流</p><ul><li><p>供了在字节流和字符流之间的转换</p></li><li><p><strong>InputStreamReader:</strong> 将一个字节的输入流转换为字符的输入流</p></li><li><p><strong>OutputStreamWriter:</strong> 将一个字符的输出流站换为字节的输出流</p></li><li><p>字节流中的数据都是字符时，转成字符流操作更高效</p></li></ul></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">//InputStreamReader</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;        InputStreamReader inputStreamReader = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"helloword.txt"</span>);            fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);            inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(fileInputStream);            <span class="hljs-keyword">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];            <span class="hljs-keyword">int</span> len;            <span class="hljs-keyword">while</span> ((len = inputStreamReader.read(c)) != -<span class="hljs-number">1</span>) &#123;                String s = <span class="hljs-keyword">new</span> String(c, <span class="hljs-number">0</span>, len);                System.out.println(s);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span> (fileInputStream != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">try</span> &#123;                    fileInputStream.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;       InputStreamReader inputStreamReader = <span class="hljs-keyword">null</span>;       OutputStreamWriter outputStreamWriter = <span class="hljs-keyword">null</span>;       FileOutputStream fileOutputStream = <span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span> &#123;           File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"helloword1.txt"</span>);           File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"helloword3.txt"</span>);           fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(file);           fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(file1);           inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(fileInputStream);           outputStreamWriter = <span class="hljs-keyword">new</span> OutputStreamWriter(fileOutputStream);           <span class="hljs-keyword">char</span>[] c = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">10</span>];           <span class="hljs-keyword">int</span> len;           <span class="hljs-keyword">while</span> ((len = inputStreamReader.read(c)) != -<span class="hljs-number">1</span>) &#123;               outputStreamWriter.write(c,<span class="hljs-number">0</span>, len);           &#125;       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;           e.printStackTrace();       &#125; <span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">if</span> (fileInputStream != <span class="hljs-keyword">null</span>) &#123;                   fileInputStream.close();               &#125;               <span class="hljs-keyword">if</span> (fileOutputStream != <span class="hljs-keyword">null</span>) &#123;                   fileOutputStream.close();               &#125;           &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;               e.printStackTrace();           &#125;       &#125;   &#125;</code></pre></div><ul><li><p>标准 输入、输出流（了解）</p><p>System.in : 标准的输入流，默认从键盘输入</p><p>System.out :  标准的输出流，默认从控制台输出</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        InputStreamReader inputStreamReader = <span class="hljs-keyword">null</span>;        BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            inputStreamReader = <span class="hljs-keyword">new</span> InputStreamReader(System.in);            bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(inputStreamReader);            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                System.out.println(<span class="hljs-string">"请输入字符串："</span>);                String data = bufferedReader.readLine();                data = data.toUpperCase();                System.out.println(data);            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                bufferedReader.close();                inputStreamReader.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre></div><ul><li><p>打印流（了解）</p><p>PrintStream </p><p>PrintWriter</p></li><li><p>数据流（了解）</p></li><li><p>对象流</p><p>ObjectInputStream </p><p>ObjectOutputStream</p><p>用于存储和读取基本数据类型数据或对象的处理流</p><p><strong>序列化 ：</strong> 用ObjectOutputStream 类保存基本数据类型或对象机制</p><p><strong>反序列化 ：</strong> 用ObjectInputStream 类保存基本数据类型或对象机制</p><p>ObjectOutputSteam 和 ObjectInputStream 不能序列化static 和 transient修饰的成员变量</p><p><strong>对象序列化机制</strong>：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        FileOutputStream fileOutputStream=<span class="hljs-keyword">null</span>;        ObjectOutputStream objectOutputStream=<span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;             fileOutputStream=<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"obi.dat"</span>));             objectOutputStream=<span class="hljs-keyword">new</span> ObjectOutputStream(fileOutputStream);             objectOutputStream.writeObject(<span class="hljs-keyword">new</span> String(<span class="hljs-string">"我爱你"</span>));             objectOutputStream.flush();        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">try</span> &#123;                objectOutputStream.close();            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;</code></pre></div><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       FileInputStream fileInputStream=<span class="hljs-keyword">null</span>;       ObjectInputStream objectInputStream=<span class="hljs-keyword">null</span>;       <span class="hljs-keyword">try</span>&#123;            fileInputStream=<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"obi.dat"</span>));            objectInputStream=<span class="hljs-keyword">new</span> ObjectInputStream(fileInputStream);            Object o=  objectInputStream.readObject();            String s=(String) o;            System.out.println(s);       &#125;<span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e)&#123;           e.printStackTrace();       &#125;<span class="hljs-keyword">finally</span> &#123;           <span class="hljs-keyword">try</span> &#123;               fileInputStream.close();           &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;               e.printStackTrace();           &#125;       &#125;    &#125;</code></pre></div><ul><li><p>RandomAccessFile</p><ul><li>直接继承了java.lang.Object类，实现了DataInput和DataOutput 接口</li></ul></li><li><p>既可以作为输入流，也可以作为输出流</p><ul><li>如果RandomAccessFile 作为输出流时，写出到文件1如果不存在，则在执行过程中自动创建，如果写出的文件存在，则会对原有的文件内容进行覆盖</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础 集合框架</title>
      <link href="/2020/08/04/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2020/08/04/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础-集合框架"><a href="#Java基础-集合框架" class="headerlink" title="Java基础   集合框架"></a>Java基础   集合框架</h2><h2 id="一、Java-集合框架概述"><a href="#一、Java-集合框架概述" class="headerlink" title="一、Java 集合框架概述"></a>一、Java 集合框架概述</h2><ol><li>集合、数组都是对多个数据进行存储操作的结构、简称Java容器;</li></ol><ol start="2"><li>数组在存储多个数据方面特点：<ul><li>一旦初始化后，其长度就确定了</li><li>数组一旦定义好，其元素类型也就确定了，我们也就只能操作指定类型的数据了</li></ul></li></ol><ol start="3"><li>数组在存储多个数据方面的缺点：<ul><li>一旦初始化以后，其长度就不可以修改了</li><li>数组中提供的方法是有限的，对于添加、删除、插入等操作，非常不便，同时效率不高</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法</li><li>数组存储数据的特点：有序、可重复。对于无序，不可重复的需求，不能满足<a id="more"></a><h2 id="二、集合框架"><a href="#二、集合框架" class="headerlink" title="二、集合框架"></a>二、集合框架</h2></li></ul></li><li>Java 集合可分为Collection 和Map 两种体系<ul><li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul><li>List : 元素有序、可重复的集合<div class="hljs code-wrapper"><pre><code>ArrayList、LinkedList、Vector</code></pre></div></li><li>Set : 元素无序、不可重复的集合<div class="hljs code-wrapper"><pre><code>HashSet、LinkedSet、TreeSet</code></pre></div></li></ul></li><li>Map接口：双列数据、保存具有映射关系“key-value”的一对的数据<ul><li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties </li></ul></li></ul></li></ol><p><img src="/2020/08/04/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/01.png" srcset="/img/loading.gif" lazyload alt></p><h2 id="三、List-接口"><a href="#三、List-接口" class="headerlink" title="三、List 接口"></a>三、List 接口</h2><h4 id="1-ArrayList、LinkedList、Vector-异同点"><a href="#1-ArrayList、LinkedList、Vector-异同点" class="headerlink" title="1. ArrayList、LinkedList、Vector  异同点"></a>1. ArrayList、LinkedList、Vector  异同点</h4><p>​    相同点：三个类都是实现了List接口、存储数据特点相同：存储有序、可重复的数据</p><p>​    不同点:   1. <strong>ArrayList</strong> :  作为List接口的主要实现类，<strong>线程不安全，效率高</strong>，底层使用Obiect[ ] elementData 存                        储;</p><p>​                    2.<strong>LinkedList</strong> : 对于频繁的插入，删除操作，使用此效率会比ArrayList 高，底层使用双向链表存储</p><p>​                    3.<strong>Vector</strong> :  <strong>线程安全，效率低</strong>，底层使用Object[ ] elementData存储</p><h4 id="2-ArrayList-源码分析"><a href="#2-ArrayList-源码分析" class="headerlink" title="2. ArrayList 源码分析"></a>2. ArrayList 源码分析</h4><h5 id="2-1-基于JDK7-情况下："><a href="#2-1-基于JDK7-情况下：" class="headerlink" title="2.1 基于JDK7 情况下："></a>2.1 基于JDK7 情况下：</h5><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList  arraylist=<span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">// 底层创建了一个长度是10的Object [ ] 数组 elementData</span>arrayList.add(<span class="hljs-number">134</span>); elementData[<span class="hljs-number">0</span>] =<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>);...arraylist.add(<span class="hljs-number">11</span>);<span class="hljs-comment">// 如果此次添加导致底层elementData数组容量不够，则扩容。默认的情况下，扩容到原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></code></pre></div><h5 id="2-2-基于JDK8情况下："><a href="#2-2-基于JDK8情况下：" class="headerlink" title="2.2 基于JDK8情况下："></a>2.2 基于JDK8情况下：</h5><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList  arraylist=<span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">// 底层Object [ ] elementData的初始化为｛｝，并没有创建长度为10的数组</span>list.add(<span class="hljs-number">123</span>);<span class="hljs-comment">//第一次调用add 时，才创建长度为10的数组，并将123添加到elementData 中</span>...<span class="hljs-comment">//后续的添加和扩容操作与jdk7无异</span></code></pre></div><h5 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h5><p>​        jdk7 中的ArrayList 的对象的创建类似于单利模式的饿汉式，而JDK 8 中的ArrayList 的对象创建类似于 单例        模式的懒汉式，延迟了数组的创建，节省内存。</p><h4 id="3-LinkedList的源码分析"><a href="#3-LinkedList的源码分析" class="headerlink" title="3. LinkedList的源码分析"></a>3. LinkedList的源码分析</h4><p>​        LinkedList list=new LinkedList(); //内部声明了Node类型的first 属性和 last 属性(size:結合长度、firs:双向链表头部、last:双向链表尾部) ;</p><p>​        list.add(123); //将123封装到Node 中，创建了Node 对象。</p><p>​        其中，Node 的定义为: 体现了LinkedList的双向链表的说法        </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;        E item;        Node&lt;E&gt; next;        Node&lt;E&gt; prev;         Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;            <span class="hljs-keyword">this</span>.item = element;            <span class="hljs-keyword">this</span>.next = next;            <span class="hljs-keyword">this</span>.prev = prev;        &#125;    &#125;</code></pre></div><h4 id="4-Vector"><a href="#4-Vector" class="headerlink" title="4. Vector"></a>4. Vector</h4><h4 id="5-迭代器与增强for循环"><a href="#5-迭代器与增强for循环" class="headerlink" title="5. 迭代器与增强for循环"></a>5. 迭代器与增强for循环</h4><h5 id="5-1-迭代器"><a href="#5-1-迭代器" class="headerlink" title="5.1 迭代器"></a>5.1 迭代器</h5><ul><li>GOF 给迭代器的定义为：提供一种方法访问一个容器对象中的各个元素，而又不需要暴露改对象的内部细节，迭代器模式，就是为容器而生；</li><li>如何是使用迭代器遍历集合？</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Collection&lt;Object&gt; collection = <span class="hljs-keyword">new</span> ArrayList();        collection.add(<span class="hljs-string">"123"</span>);        collection.add(<span class="hljs-string">"你好啊"</span>);        collection.add(<span class="hljs-number">456</span>);        System.out.println(collection);        Iterator&lt;Object&gt; ite = collection.iterator();    <span class="hljs-comment">//hasNext();判断是否还有下一个元素</span>        <span class="hljs-keyword">while</span> (ite.hasNext()) &#123;            <span class="hljs-comment">//next();1.指针下移；2.将下移后集合位置上的返回</span>            System.out.println(ite.next());        &#125;    &#125;</code></pre></div><ul><li>Iterator 接口remove（）方法</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Collection&lt;Object&gt; collection = <span class="hljs-keyword">new</span> ArrayList();        collection.add(<span class="hljs-string">"123"</span>);        collection.add(<span class="hljs-string">"你好啊"</span>);        collection.add(<span class="hljs-number">456</span>);        System.out.println(collection);        Iterator&lt;Object&gt; ite = collection.iterator();        <span class="hljs-keyword">while</span> (ite.hasNext()) &#123;            Object object=ite.next();            <span class="hljs-keyword">if</span> (object.equals(<span class="hljs-number">456</span>)) &#123;                ite.remove();            &#125;            <span class="hljs-comment">//System.out.println(ite.next());</span>        &#125;    &#125;</code></pre></div><ul><li>注意<ul><li>Iterator 可以删除集合元素，但是遍历过程中通过迭代器对象的remove()方法，不是集合的remove()方法</li><li><strong>如果还为调用next（）方法或在上一次调用next()方法之后已经调用了remove（）方法</strong>，再调用remove都会报lllegalStateException</li></ul></li></ul><h5 id="5-2-增强for循环-foreach"><a href="#5-2-增强for循环-foreach" class="headerlink" title="5.2 增强for循环(foreach)"></a>5.2 增强for循环(foreach)</h5><ul><li><p>增强for循环的作用： 简化迭代器的书写格式。(注意：增强for循环的底层还是使用了迭代器遍历。)</p></li><li><p>增强for循环的适用范围： 如果是实现了Iterable接口的对象或者是数组对象都可以使用增强for循环。</p></li><li><p>增强for循环的缺点：增强for循环和iterator遍历的效果是一样的，也就说增强for循环的内部也就是调用iteratoer实现的，但是增强for循环有些缺点，例如不能在增强循环里动态的删除集合内容、不能获取下标等。</p></li><li><p>增强for循环的格式：</p><p>for(数据类型 变量名 :遍历的目标){ //数据类型 变量名:声明一个变量用来接收遍历目标遍历后的元素</p><p>}</p></li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Collection&lt;Object&gt; collection = <span class="hljs-keyword">new</span> ArrayList();        collection.add(<span class="hljs-string">"123"</span>);        collection.add(<span class="hljs-string">"你好啊"</span>);        collection.add(<span class="hljs-number">456</span>);        System.out.println(collection);        <span class="hljs-keyword">for</span>(Object objects: collection)&#123;            System.out.println(objects);        &#125;    &#125;</code></pre></div><h4 id="6-Collection集合与数组之间的转换"><a href="#6-Collection集合与数组之间的转换" class="headerlink" title="6.Collection集合与数组之间的转换"></a>6.Collection集合与数组之间的转换</h4><ul><li>集合——数组</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Collection&lt;Object&gt; collection = <span class="hljs-keyword">new</span> ArrayList();        collection.add(<span class="hljs-string">"123"</span>);        collection.add(<span class="hljs-string">"你好啊"</span>);        collection.add(<span class="hljs-string">"456"</span>);        Object[] a = collection.toArray();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;a.length; i++) &#123;            System.out.println(a[i]);        &#125;    &#125;</code></pre></div><ul><li>数组—–集合</li></ul><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;       Integer a[]= &#123;<span class="hljs-number">123</span>,<span class="hljs-number">345</span>,<span class="hljs-number">4433</span>&#125;;       List list= Arrays.asList(a);       System.out.println(list);   &#125;</code></pre></div><h5 id="List-接口的常用方法（增、删、改、查、插、长度、遍历）"><a href="#List-接口的常用方法（增、删、改、查、插、长度、遍历）" class="headerlink" title="List 接口的常用方法（增、删、改、查、插、长度、遍历）"></a>List 接口的常用方法（增、删、改、查、插、长度、遍历）</h5><ul><li><p>add(Object object);</p></li><li><p>remove（int index）/remove(Object object);</p></li><li><p>set(int index,Object object);</p></li><li><p>get(int index);</p></li><li><p>add(int index,Object);</p></li><li><p>size();</p></li></ul><h3 id="四、Set-接口"><a href="#四、Set-接口" class="headerlink" title="四、Set 接口"></a>四、Set 接口</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>​    Java中Set接口继承自Collection接口，Set接口的实现类无序并且不可重复，这里的无序指的是添加的顺序和内部真实排列顺序无关。Set接口的实现类常用的有HashSet和TreeSet。</p><h4 id="2-HashSet"><a href="#2-HashSet" class="headerlink" title="2.HashSet"></a>2.HashSet</h4><h4 id="3-TreeSet"><a href="#3-TreeSet" class="headerlink" title="3.TreeSet"></a>3.TreeSet</h4><h4 id="4-LinkedHashSet"><a href="#4-LinkedHashSet" class="headerlink" title="4.LinkedHashSet"></a>4.LinkedHashSet</h4><h3 id="五、Map-接口"><a href="#五、Map-接口" class="headerlink" title="五、Map 接口"></a>五、Map 接口</h3><h4 id="1-Map"><a href="#1-Map" class="headerlink" title="1.Map"></a>1.Map</h4><h4 id="2-HashMap的底层实现原理"><a href="#2-HashMap的底层实现原理" class="headerlink" title="2. HashMap的底层实现原理"></a>2. HashMap的底层实现原理</h4><p>以JDK 7 为例：<br>HashMap  hashmap=new HashMap();<br>在实例化过后，底层创建一个长度16 的一维数组Entry[ ] table,<br>……<br>hasmap.put(key1,value1);<br>首先，调用key1,所在类的hasCode( ),计算key1哈希值，此哈希值经过某种计算以后，得到在Entry数组中存放的位置。</p><ol><li>如果此位置上的数据为空，此时的key1-value添加成功。（情况1）</li><li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据（以链表形式存在），比较key1和已经存在的一个或多个数据的哈希值)：<ul><li>如果key1的哈希值与已经存在的数据哈希值都不相同，此时的key1-value1 添加成功；（情况2）</li><li>如果key1的哈希值和已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用key1所在类的equals(key2)<ul><li>如果equals（）方法返回false, 此时key1-value1添加成功。（情况3）</li><li>如果equals（）方法返回true,使用value1 替换value2。</li></ul></li></ul></li></ol><p> 补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。<br> 在不断添加的过程中，会涉及扩容的问题，默认的方式：扩容到原来的2倍，并原有数据复制过来</p><p> JDK 8相较于JDK 7在底层实现方面不同：<br>    1. new HashMap( ); 底层没有创建一个长度为16 的数组；<br>    2. JDK 8底层数组是Node[ ] 而不是Entry[ ]<br>    3. 首次调用put( )方法时，创建长度16 的数组<br>    4. JDK7 底层结构只有数组+链表，JDK8中底层结构：数组+链表+红黑树<br>        当数组索引位置的某一个位置上的元素以链表形式存在的数据个数 &gt; 8 且当前的数组的长度 &gt;64 时，此时此索引位置上的所有数据改为使用红黑树存储。</p><h4 id="3-LinkedHashMap的底层实现原理（了解）"><a href="#3-LinkedHashMap的底层实现原理（了解）" class="headerlink" title="3. LinkedHashMap的底层实现原理（了解）"></a>3. LinkedHashMap的底层实现原理（了解）</h4><h4 id="4-Map中定义的方法"><a href="#4-Map中定义的方法" class="headerlink" title="4. Map中定义的方法"></a>4. Map中定义的方法</h4><ul><li><p>添加、删除、修改操作：</p><p> Object put(key,value) ： 将指定的key-value 添加到或修改到当前map对象中；</p><p> void putAll(Map map ) : 将map 中的所有key-value对存放到当前map中；</p><p> Object remove(Object key) : 移除指定key的key-value对，并返回value;</p><p> void clear( ) : 清空当前map中的数据</p></li><li><p>元素查询操作：</p><p> Object get(Object key ) : 获取指定key对应的value;</p><p> boolean containsKey(Object key) : 是否包含指定的key;</p><p> boolean containsValue(Object value ) ：是否包含指定的value;</p><p> int size( ); 返回map 中key-value对的个数；</p><p> boolean isEmpty( ) : 判断当前map是否为空；</p><p> boolean equals(Object obj ) : 判断当前的map和参数对象obj是否相等；</p></li><li><p>元视图操作方法：</p><p>  Set keySet( ) : 返回所有key构成的集合 ；</p><p>  Collection values( ) : 返回所有value构成的Collection集合；</p><p>  Set entrySet( ) : 返回所有key-value对构成的集合</p></li></ul><h3 id="六、Collections-工具类使用"><a href="#六、Collections-工具类使用" class="headerlink" title="六、Collections 工具类使用"></a>六、Collections 工具类使用</h3><ol><li><p>Collections 是操作Set 、List、和Map 等集合的工具类；</p></li><li><p>常用方法：</p><ul><li>reverse(List); 反转list中元素的顺序</li><li>shuffle(List); 对List中元素随机排序</li><li>sort(List)；根据元素的自然顺序对指定的List集合按元素升序排序</li><li>sort(List,Comparator); 根据指定的Comparator产生的顺序对List集合进行排序</li><li>swap(List,int,int); 将指定的list集合中的i处元素和j处元素进行交换</li><li>Object max(Collection); 根据自然顺序，返回集合最大的元素</li><li>Object max(Collection,Comparator); 根据Comparator指定的顺序，返回集合中        最大的元素</li><li>Object min(Collection);</li><li>Object min(Collection,Comparator);</li><li>int frequency(Collection,Object); 返回集合中指定的元素的出现次数</li><li>void copy(List dest,List src); 将src 中的内容复制到dest中</li><li>boolean replaceAll(List list,Object oldVal,Object newVal);使用新值替换List对        象</li></ul></li><li><p>Collections中提供多个synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全</p></li></ol><div class="hljs code-wrapper"><pre><code class="hljs java">List list1=Collections.synchronizedList(list);</code></pre></div><p>​<br>​    </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用百度智能云实现文字、身份证识别等</title>
      <link href="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/"/>
      <url>/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<p> 根据公司业务需求，近期在做一个平台，其中需要对用户进行实名认证。在用户上传身份证之后自动识别身份证上的信息，然后提交相关的信息进行验证。</p><p>​        在网上搜索后了解到了百度智能云的文字识别，详细了解一下发现还不错，不足的是身份证等识别接口每天只有500次的免费额度，如果每天量比较大的多话就需要花钱了，由于前期需求量小，暂且接入此接口。</p><h3 id="一、准备步骤："><a href="#一、准备步骤：" class="headerlink" title="一、准备步骤："></a>一、准备步骤：<a id="more"></a></h3><ul><li><p>首先需要登录<a href="https://cloud.baidu.com/" target="_blank" rel="noopener">百度智能云</a>，进入控制台，找到文字识别，点击创建应用,填写相关信息；</p><p><img src="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/1.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/2.png" srcset="/img/loading.gif" lazyload alt></p></li><li><p>创建完成之后，在管理应用中可以找到我们需要的 API Key 和Secret Key </p><p><img src="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/3.png" srcset="/img/loading.gif" lazyload alt></p></li></ul><h3 id="二、开发"><a href="#二、开发" class="headerlink" title="二、开发"></a>二、开发</h3><ul><li><p>首先我们 需要<strong>获取access_token</strong>  </p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baidu.ai.aip.auth;<span class="hljs-keyword">import</span> org.json.JSONObject;<span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-keyword">import</span> java.net.HttpURLConnection;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-comment">/** * 获取token类 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthService</span> </span>&#123;    <span class="hljs-comment">/**     * 获取权限token     * <span class="hljs-doctag">@return</span> 返回示例：     * &#123;     * "access_token": "24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567",     * "expires_in": 2592000     * &#125;     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getAuth</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 官网获取的 API Key 更新为你注册的</span>        String clientId = <span class="hljs-string">"百度云应用的AK"</span>;        <span class="hljs-comment">// 官网获取的 Secret Key 更新为你注册的</span>        String clientSecret = <span class="hljs-string">"百度云应用的SK"</span>;        <span class="hljs-keyword">return</span> getAuth(clientId, clientSecret);    &#125;    <span class="hljs-comment">/**     * 获取API访问token     * 该token有一定的有效期，需要自行管理，当失效时需重新获取.     * <span class="hljs-doctag">@param</span> ak - 百度云官网获取的 API Key     * <span class="hljs-doctag">@param</span> sk - 百度云官网获取的 Securet Key     * <span class="hljs-doctag">@return</span> assess_token 示例：     * "24.460da4889caad24cccdb1fea17221975.2592000.1491995545.282335-1234567"     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getAuth</span><span class="hljs-params">(String ak, String sk)</span> </span>&#123;        <span class="hljs-comment">// 获取token地址</span>        String authHost = <span class="hljs-string">"https://aip.baidubce.com/oauth/2.0/token?"</span>;        String getAccessTokenUrl = authHost                <span class="hljs-comment">// 1. grant_type为固定参数</span>                + <span class="hljs-string">"grant_type=client_credentials"</span>                <span class="hljs-comment">// 2. 官网获取的 API Key</span>                + <span class="hljs-string">"&amp;client_id="</span> + ak                <span class="hljs-comment">// 3. 官网获取的 Secret Key</span>                + <span class="hljs-string">"&amp;client_secret="</span> + sk;        <span class="hljs-keyword">try</span> &#123;            URL realUrl = <span class="hljs-keyword">new</span> URL(getAccessTokenUrl);            <span class="hljs-comment">// 打开和URL之间的连接</span>            HttpURLConnection connection = (HttpURLConnection) realUrl.openConnection();            connection.setRequestMethod(<span class="hljs-string">"GET"</span>);            connection.connect();            <span class="hljs-comment">// 获取所有响应头字段</span>            Map&lt;String, List&lt;String&gt;&gt; map = connection.getHeaderFields();            <span class="hljs-comment">// 遍历所有的响应头字段</span>            <span class="hljs-keyword">for</span> (String key : map.keySet()) &#123;                System.err.println(key + <span class="hljs-string">"---&gt;"</span> + map.get(key));            &#125;            <span class="hljs-comment">// 定义 BufferedReader输入流来读取URL的响应</span>            BufferedReader in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(connection.getInputStream()));            String result = <span class="hljs-string">""</span>;            String line;            <span class="hljs-keyword">while</span> ((line = in.readLine()) != <span class="hljs-keyword">null</span>) &#123;                result += line;            &#125;            <span class="hljs-comment">/**             * 返回结果示例             */</span>            System.err.println(<span class="hljs-string">"result:"</span> + result);            JSONObject jsonObject = <span class="hljs-keyword">new</span> JSONObject(result);            String access_token = jsonObject.getString(<span class="hljs-string">"access_token"</span>);            <span class="hljs-keyword">return</span> access_token;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            System.err.printf(<span class="hljs-string">"获取token失败！"</span>);            e.printStackTrace(System.err);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre></div><ul><li>获取token 之后就可以进行下一步操作了，进行身份证的识别</li></ul></li></ul><p><img src="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/4.png" srcset="/img/loading.gif" lazyload alt></p><p><img src="/2020/03/18/%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6%E6%99%BA%E8%83%BD%E4%BA%91%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E3%80%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E8%AF%86%E5%88%AB%E7%AD%89/5.png" srcset="/img/loading.gif" lazyload alt></p><p>代码示例:</p><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baidu.ai.aip;<span class="hljs-keyword">import</span> com.baidu.ai.aip.utils.Base64Util;<span class="hljs-keyword">import</span> com.baidu.ai.aip.utils.FileUtil;<span class="hljs-keyword">import</span> com.baidu.ai.aip.utils.HttpUtil;<span class="hljs-keyword">import</span> java.net.URLEncoder;<span class="hljs-comment">/*** 身份证识别*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Idcard</span> </span>&#123;    <span class="hljs-comment">/**    * 重要提示代码中所需工具类    * FileUtil,Base64Util,HttpUtil,GsonUtils请从    * https://ai.baidu.com/file/658A35ABAB2D404FBF903F64D47C1F72    * https://ai.baidu.com/file/C8D81F3301E24D2892968F09AE1AD6E2    * https://ai.baidu.com/file/544D677F5D4E4F17B4122FBD60DB82B3    * https://ai.baidu.com/file/470B3ACCA3FE43788B5A963BF0B625F3    * 下载    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">idcard</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 请求url</span>        String url = <span class="hljs-string">"https://aip.baidubce.com/rest/2.0/ocr/v1/idcard"</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// 本地文件路径</span>            String filePath = <span class="hljs-string">"[本地文件路径]"</span>;            <span class="hljs-keyword">byte</span>[] imgData = FileUtil.readFileByBytes(filePath);            String imgStr = Base64Util.encode(imgData);            String imgParam = URLEncoder.encode(imgStr, <span class="hljs-string">"UTF-8"</span>);            String param = <span class="hljs-string">"id_card_side="</span> + <span class="hljs-string">"front"</span> + <span class="hljs-string">"&amp;image="</span> + imgParam;            <span class="hljs-comment">// 注意这里仅为了简化编码每一次请求都去获取access_token，线上环境access_token有过期时间， 客户端可自行缓存，过期后重新获取。</span>            String accessToken = <span class="hljs-string">"[调用鉴权接口获取的token]"</span>;            String result = HttpUtil.post(url, accessToken, param);            System.out.println(result);            <span class="hljs-keyword">return</span> result;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Idcard.idcard();    &#125;&#125;</code></pre></div><p>注意： </p><ol><li>图像数据，base64编码后进行urlencode ；</li><li>有的base64编码后有头部“Base64：”要去掉</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决小程序 app.js中的onLaunch中的数据 在page的onLoade中接收不到的问题</title>
      <link href="/2020/03/09/%E8%A7%A3%E5%86%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%20app.js%E4%B8%AD%E7%9A%84onLaunch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%20%E5%9C%A8page%E7%9A%84onLoade%E4%B8%AD%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2020/03/09/%E8%A7%A3%E5%86%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F%20app.js%E4%B8%AD%E7%9A%84onLaunch%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%20%E5%9C%A8page%E7%9A%84onLoade%E4%B8%AD%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="一、问题阐述"><a href="#一、问题阐述" class="headerlink" title="一、问题阐述"></a>一、问题阐述</h3><p>​      由于工作的安排，最近在改我们公司的一个小程序，在此期间碰到了一个坑，遇到的问题是，实现登录时，app.js中 onLaunch 实现数据请求拿到后端返回的参数后写入 Storage ，然后在首页 Storage 取信息，但是并未能取到这个参数。调试后发现  app.js onLaunch并没有先于onLoad 执行完再执行，而是onLoad先执行完 ，所以进入首页未能取到相关参数。<a id="more"></a>跟踪了一下问题发现，app.js onLaunch  中登录的请求时异步的，这就可能导致请求的参数在page onLoade 执行完后才会返回。</p><h3 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h3><h3 id="1-第一种方法：定义一个回调函数-。"><a href="#1-第一种方法：定义一个回调函数-。" class="headerlink" title="1 . 第一种方法：定义一个回调函数 。"></a>1 . 第一种方法：定义一个回调函数 。</h3><p>​       Page页面判断一下当前app.globalData.employId是否有值，如果没有（第一次）则定义定义一个app方法（回调函数）app.employIdCallback = employId =&gt; {…}。App页面在请求success后判断时候有Page页面定义的回调方法，如果有就执行该方法 ，实现代码：</p><p>​        app.js </p><div class="hljs code-wrapper"><pre><code class="hljs javascript">reLogin: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">app</span>) </span>&#123;       <span class="hljs-comment">// 执行登录，获取用户身份标识openid</span>       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"2.现在执行到 reLogin"</span>);       <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;       <span class="hljs-comment">//return new Promise((resolve, reject) =&gt; &#123;</span>       swan.login(&#123;           <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;               <span class="hljs-built_in">console</span>.log(res);               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"3.现在执行到  swan.login"</span>);               swan.request(&#123;                   <span class="hljs-attr">url</span>: that.globalData.loginUrl,                   <span class="hljs-attr">data</span>: &#123;                       <span class="hljs-attr">act</span>: <span class="hljs-string">'BDXCXlogin'</span>,                       <span class="hljs-attr">code</span>: res.code,                   &#125;,                   <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                       <span class="hljs-comment">// swan.setStorageSync("sessionid", res.header["Set-Cookie"]);</span>                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login check statusCode:"</span> + res.statusCode);                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"4.现在请求后台登录"</span>);                       <span class="hljs-built_in">console</span>.log(res.data);                       <span class="hljs-keyword">if</span> (res.statusCode == <span class="hljs-number">200</span>) &#123;                           <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">JSON</span>.parse(res.data);                          <span class="hljs-comment">// var result = res.data;</span>                           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result的val："</span> + result);                           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"result.retcode的值："</span> + result.retcode);                           <span class="hljs-keyword">if</span> (result.retcode == <span class="hljs-string">'SUCCESS'</span>) &#123;                               swan.setStorage(&#123;                                   <span class="hljs-attr">key</span>: <span class="hljs-string">""</span> + that.globalData.tokenName + <span class="hljs-string">""</span>,                                   <span class="hljs-attr">data</span>: <span class="hljs-string">""</span> + result.token + <span class="hljs-string">""</span>,                                   <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"登录成功后将token存储完成：storage token success"</span>);                                   &#125;,                                   <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;                                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"storage token failed"</span>);                                   &#125;                               &#125;)                               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"当前token"</span> + result.token);                               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"现在执行 resolve1"</span>);                               <span class="hljs-comment">//resolve(result.token);</span>                               <span class="hljs-keyword">if</span> (that.employIdCallback) &#123;                                   that.employIdCallback(result.token);                               &#125;                           &#125; <span class="hljs-keyword">else</span> &#123;                               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login check failed:"</span> + result.retmsg);                               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"现在执行 reject1"</span>);                               <span class="hljs-comment">// reject(result.retmsg);</span>                           &#125;                       &#125; <span class="hljs-keyword">else</span> &#123;                           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login request network error:"</span> + res.statusCode);                           swan.showToast(&#123; <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'login request network error:'</span> + res.statusCode + <span class="hljs-string">''</span> &#125;)                           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"现在执行 reject2"</span>);                           <span class="hljs-comment">//  reject(res.statusCode);</span>                       &#125;                       <span class="hljs-comment">//resolve(result.token);</span>                   &#125;,                   <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"现在执行 reject3"</span>);                       <span class="hljs-comment">// reject(res);</span>                       <span class="hljs-built_in">console</span>.log(res);                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"login request failed"</span>);                       swan.showToast(&#123; <span class="hljs-attr">icon</span>: <span class="hljs-string">'none'</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'login request failed'</span> &#125;)                   &#125;,                   <span class="hljs-attr">complete</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;                       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'login request completed'</span>);                       swan.hideLoading();                       swan.hideNavigationBarLoading();                   &#125;               &#125;);           &#125;,           <span class="hljs-attr">fail</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'swan login fail'</span>, err);           &#125;       &#125;);       <span class="hljs-comment">// &#125;)</span>   &#125;</code></pre></div><p>​          indx.js</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">onLoad(query) &#123;       <span class="hljs-comment">// 页面加载 </span>       <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;       <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"现在进入webview.js"</span>);       <span class="hljs-built_in">console</span>.info(<span class="hljs-string">`Page onLoad with query: <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(query)&#125;</span>`</span>);       <span class="hljs-built_in">console</span>.info(query);       <span class="hljs-keyword">var</span> token = swan.getStorageSync(app.globalData.tokenName);       <span class="hljs-keyword">if</span> (token.length &gt; <span class="hljs-number">0</span>) &#123;           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"webview.js  getStorageSync 获取  token&gt;&gt;"</span> + token);           <span class="hljs-keyword">this</span>.setData(&#123;               <span class="hljs-attr">weburl</span>: <span class="hljs-string">''</span> + app.globalData.weburl + <span class="hljs-string">'?tokenData='</span> + token + <span class="hljs-string">''</span>,           &#125;)       &#125;       <span class="hljs-keyword">else</span> &#123;           <span class="hljs-comment">// app.reLogin().then((res) =&gt; &#123;</span>           <span class="hljs-comment">//     var token = swan.getStorageSync(app.globalData.tokenName);</span>           <span class="hljs-comment">//     console.log('现在执行app.reLogin().then' +token);</span>           <span class="hljs-comment">//     console.log('当前res数据:' + res);</span>           <span class="hljs-comment">//     console.log('token2' + res);</span>           <span class="hljs-comment">//     this.setData(&#123;</span>           <span class="hljs-comment">//         weburl: '' + app.globalData.weburl + '?tokenData=' + res + '',</span>           <span class="hljs-comment">//     &#125;)</span>           <span class="hljs-comment">// &#125;, (error) =&gt; &#123;</span>           <span class="hljs-comment">//     console.log('失败：' + error)</span>           <span class="hljs-comment">// &#125;)</span>           <span class="hljs-comment">//为了解决小程序数据请求异步问题 ，app.js onLaunch 中数据请求的数据可能在paages  onLoad 之后才返回 </span>           app.employIdCallback = <span class="hljs-function"><span class="hljs-params">account</span> =&gt;</span> &#123;               <span class="hljs-keyword">var</span> token = swan.getStorageSync(app.globalData.tokenName);               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'现在执行app.reLogin().then'</span> + token);               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'当前res数据:'</span> + account);               <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'token2'</span> + token);               <span class="hljs-keyword">this</span>.setData(&#123;                   <span class="hljs-attr">weburl</span>: <span class="hljs-string">''</span> + app.globalData.weburl + <span class="hljs-string">'?tokenData='</span> + token + <span class="hljs-string">''</span>,               &#125;)           &#125;       &#125;   &#125;,</code></pre></div><h3 id="2-第二种方法-：-使用promise，判断进程状态，在index中去判断进程状态，再去执行页面的加载"><a href="#2-第二种方法-：-使用promise，判断进程状态，在index中去判断进程状态，再去执行页面的加载" class="headerlink" title="2. 第二种方法  ：  使用promise，判断进程状态，在index中去判断进程状态，再去执行页面的加载"></a>2. 第二种方法  ：  使用promise，判断进程状态，在index中去判断进程状态，再去执行页面的加载</h3><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123; resolve(value); &#125; <span class="hljs-keyword">else</span> &#123; reject(error); &#125;&#125;);promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-comment">// success</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123; <span class="hljs-comment">// failure</span>&#125;);</code></pre></div><p>​     Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。</p><p>​    如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）；</p><p>​    如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。</p><p><strong>具体实现的代码见第一种方法中的注释部分</strong></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手教你搭建hexo个人博客</title>
      <link href="/2019/11/30/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/11/30/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​     前段时间，心血来潮，想搭建一个个人博客网站，对于一个程序员来书，拥有一个博客是一个非常必要的事，紧接着我在网上了解到了hexo 。用hexo 来搭建一个个人博客是非常便捷的，仅需要我们进行相关的配置，即可拥有一个高逼格的个人博客了。<a id="more"></a></p><p>废话不多说，我们开始！</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li>安装Git</li><li>安装node.js</li><li>安装hexo</li><li>更换主题</li><li>发布文章</li><li>部署到github</li></ul><h2 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h2><p>相信大家对于Git 都并不陌生，网上有很多关于Git 的教程和安装说明，这里就不过多的赘述，推荐廖雪峰的一篇Git<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496" target="_blank" rel="noopener">教程</a>。</p><h2 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2.安装node.js"></a>2.安装node.js</h2><h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>安装好Git与node.js之后，新建文件夹blog(任意名即可) 之后通过cd 进入此文件夹（或者在此文件夹右键git bash）,输入命令：</p><div class="hljs code-wrapper"><pre><code class="hljs java">npm install -g hexo-cli</code></pre></div><p>  安装结束后可以使用hexo -v 查看版本，接下来输入：</p><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo init myblog</span></code></pre></div><p>进行初始化操作（myblog任意名都行，根据自己需求）</p><p>紧接着 cd  myblog 进入这个文件夹</p><div class="hljs code-wrapper"><pre><code class="hljs 1c">npm install  <span class="hljs-comment">//安装所有依赖</span></code></pre></div><p>此时我们hexo 安装完成，指定的文件夹目录：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><div class="hljs code-wrapper"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><span class="hljs-attr">hexo</span> <span class="hljs-string">s</span></code></pre></div><p>打开hexo 服务，在浏览器输入 localhost:4000 就查看你的博客了。</p><h2 id="4-更换主题"><a href="#4-更换主题" class="headerlink" title="4. 更换主题"></a>4. 更换主题</h2><p>这时我们会发现，刚开始的博客并不是非常的好看，但是有很多的主题供我们选择，这里我比较推荐next 这个主题，并且网上的教程很多。<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">使用文档</a>。</p><h3 id="安装next"><a href="#安装next" class="headerlink" title="安装next"></a>安装next</h3><div class="hljs code-wrapper"><pre><code class="hljs vim">$ <span class="hljs-keyword">cd</span> your-hexo-site$ git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/iissnan/hexo-theme-<span class="hljs-keyword">next</span> themes/<span class="hljs-keyword">next</span></code></pre></div><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p> 与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 <strong>站点配置文件</strong>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code> </p><div class="hljs code-wrapper"><pre><code class="hljs autoit">theme: <span class="hljs-keyword">next</span></code></pre></div><p>此时，我们的个人博客得主题就变成next 了，更多的配置以及使用方法都在使用文档中以及网上各种美化教程，我们都可以慢慢摸索。这里推荐一两个我看过的教程：<a href="https://blog.csdn.net/nightmare_dimple/article/details/86661502" target="_blank" rel="noopener">Hexo博客优化之Next主题美化</a>、<a href="https://blog.csdn.net/qq_31279347/article/details/82427562" target="_blank" rel="noopener">Hexo Next主题进阶详细教程</a>。后期也会写一些相关的教程。</p><h2 id="5-发布文章"><a href="#5-发布文章" class="headerlink" title="5.发布文章"></a>5.发布文章</h2><p>输入：</p><div class="hljs code-wrapper"><pre><code class="hljs gauss">hexo <span class="hljs-keyword">new</span> <span class="hljs-built_in">title</span> 你的文章名字</code></pre></div><p>此时就会在\myblog\source_posts中新建一个.md文件，打开此文件在里面输入你想要发表的内容（makedown语法）。</p><h2 id="6-部署到GitHub"><a href="#6-部署到GitHub" class="headerlink" title="6.部署到GitHub"></a>6.部署到GitHub</h2><h3 id="创建个人仓库"><a href="#创建个人仓库" class="headerlink" title="创建个人仓库"></a>创建个人仓库</h3><p>GitHub.com中看到一个New repository，新建仓库 </p><p>创建一个和你用户名相同的仓库，<a href="http://xn--yfr16an19l.github.io/" target="_blank" rel="noopener">后面加.github.io</a>，只有这样，将来要部署到GitHub page的时候，才会被识别，<a href="http://xn--xxxx-4m5f354ev5p.github.io/" target="_blank" rel="noopener">也就是xxxx.github.io</a>，其中xxx就是你注册GitHub的用户名 , 点击create repository .</p><p>在你博客个根目录，右键git bash:</p><div class="hljs code-wrapper"><pre><code class="hljs verilog">git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">"yourname"</span><span class="hljs-comment">//GitHub用户名</span>git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">"youremail"</span><span class="hljs-comment">// GitHub的邮箱</span></code></pre></div><p>检验输入结果:</p><div class="hljs code-wrapper"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>user.namegit<span class="hljs-built_in"> config </span>user.email</code></pre></div><p> 然后创建SSH ：</p><div class="hljs code-wrapper"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">"youremail"</span></code></pre></div><p> 这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。 其中，id_rsa是你这台电脑的私人秘钥，id_rsa.pub是公共秘钥,把这个公钥放在GitHub上，而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key,把你的id_rsa.pub里面的信息复制进去。</p><p> 查看是否成功 :</p><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-T</span> <span class="hljs-selector-tag">git</span>@<span class="hljs-keyword">github</span>.<span class="hljs-keyword">com</span></code></pre></div><p>这个时候我们就可以部署在github上了，打开 站点配置文件 <code>_config.yml</code> ，找到 deploy ，并修改为：</p><div class="hljs code-wrapper"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:  <span class="hljs-attribute">type</span>: git  <span class="hljs-attribute">repo</span>: <span class="hljs-attribute">https</span>:<span class="hljs-comment">//github.com/YourgithubName/YourgithubName.github.io.git</span>  <span class="hljs-attribute">branch</span>: master</code></pre></div><p>然后安装 deploy-git ，</p><div class="hljs code-wrapper"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre></div><p>最后：</p><div class="hljs code-wrapper"><pre><code class="hljs verilog">hexo cleanhexo <span class="hljs-keyword">generate</span>hexo deploy</code></pre></div><p>这是我们就就可以通过 <a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 来访问你的个人博客了。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO Next 主题 添加在线联系功能</title>
      <link href="/2019/11/17/HEXO%20Next%20%E4%B8%BB%E9%A2%98%20%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/11/17/HEXO%20Next%20%E4%B8%BB%E9%A2%98%20%E6%B7%BB%E5%8A%A0%E5%9C%A8%E7%BA%BF%E8%81%94%E7%B3%BB%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<p>在我们使用hexo 搭建我们个人博客时，我们可以使用DaoVoice 为我们的博客添加在线联系的功能。<br>效果：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20191117211422673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMzc2ODM0NTg5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>首先我们需要进行注册，<a href="http://www.daovoice.io/" target="_blank" rel="noopener">点击前往注册</a>，注册成功之后进入控制台，应用设置&gt;安装到网站,获取我们所需要的app_id：<br><img src="https://img-blog.csdnimg.cn/20191117205343685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMzc2ODM0NTg5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>接下我们需要在主题中进行一些配置，这边使用的是next主题，就以next主题为例：<br>打开文件\themes\next\layout_partials\head\head.swig,任意位置插入以下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;% <span class="hljs-keyword">if</span> theme.daovoice %&#125;  &lt;script&gt;  (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class="hljs-string">"DaoVoiceObject"</span>]=r;i[r]=i[r]||<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class="hljs-built_in">arguments</span>)&#125;,i[r].l=<span class="hljs-number">1</span>*<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="hljs-number">0</span>];a.async=<span class="hljs-number">1</span>;a.src=g;a.charset=<span class="hljs-string">"utf-8"</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class="hljs-built_in">window</span>,<span class="hljs-built_in">document</span>,<span class="hljs-string">"script"</span>,(<span class="hljs-string">'https:'</span> == <span class="hljs-built_in">document</span>.location.protocol ? <span class="hljs-string">'https:'</span> : <span class="hljs-string">'http:'</span>) + <span class="hljs-string">"//widget.daovoice.io/widget/你的app_id.js"</span>,<span class="hljs-string">"daovoice"</span>)  daovoice(<span class="hljs-string">'init'</span>, &#123;      <span class="hljs-attr">app_id</span>: <span class="hljs-string">"&#123;&#123;theme.daovoice_app_id&#125;&#125;"</span>    &#125;);  daovoice(<span class="hljs-string">'update'</span>);  <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>&#123;% endif %&#125;</code></pre></div><p>在主题配置文件中插入以下代码：</p><div class="hljs code-wrapper"><pre><code class="hljs javascript"># Online contact daovoice: truedaovoice_app_id: 这里输入前面获取的app_id</code></pre></div><p>以上就是我们需要配置的内容，配置完成之后，我们进行hexo clean,hexo s 即可查看效果。不过此时我们会发现，DaoVoice 的图标会与我们博客上的按钮重合，影响使用，这时候我们可以在“聊天设置”中进行设置：<br><img src="https://img-blog.csdnimg.cn/20191117210753372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMzc2ODM0NTg5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191117210811553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3cxMzc2ODM0NTg5,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"><br>我们通过hexo s 一边修改一遍测试直到我们满意的效果。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
